(defun cal-mode-version ()
  (interactive)
  cal-version-string)

(defconst cal-version "7.03a")
(defconst cal-version-string
      (concat "CAL version " cal-version " of Sun Nov 27 12:31:49 2005"))

;; CAL version 7.03 of Sun Nov 27 12:31:49 2005
;; CAL version 7.02 of Sat May  8 16:06:25 2004
;; CAL version 7.01 of Thu Apr 15 11:53:49 2004
;; CAL version 6.22 of Tue Dec 23 23:32:00 2003
;; CAL version 6.21 of Sun Dec 14 11:25:59 2003
;; CAL version 6.20 of Sun Dec  7 12:34:31 2003
;; CAL version 6.19 of Sat Nov 29 23:14:23 2003
;; CAL version 6.18 of Fri Nov 28 16:29:37 2003
;; CAL version 6.17 of Thu Nov 27 15:22:49 2003
;; CAL version 6.16 of Mon Nov 24 13:02:10 2003
;; CAL version 6.15 of Sun Nov 23 11:24:10 2003
;; CAL version 6.14 of Sat Nov 22 13:20:54 2003
;; CAL version 6.13 of Tue Nov 18 23:22:33 2003
;; CAL version 6.12 of Sun Nov 16 12:52:46 2003
;; CAL version 6.11 of Sat Nov  1 20:47:00 2003
;; CAL version 6.10 of Wed Oct 29 11:51:49 2003
;; CAL version 6.09 of Mon Oct 27 11:46:56 2003
;; CAL version 6.08 of Thu Oct 23 11:26:31 2003
;; CAL version 6.07 of Mon Oct 20 18:49:16 2003
;; CAL version 6.06 of Mon Oct 13 12:19:42 2003
;; CAL version 6.05 of Mon Oct  6 23:50:50 2003
;; CAL version 6.04 of Tue Sep 30 22:56:32 2003
;; CAL version 6.03 of Mon Sep 29 15:30:27 2003
;; CAL version 6.02 of Mon Jun 23 14:04:27 2003
;; CAL version 6.01 of Sat Mar 22 10:17:42 2003
;; CAL version 5.34 of Sun Feb  9 21:31:15 2003
;; CAL version 5.33 of Wed Jan 29 11:21:21 2003
;; CAL version 5.32 of Mon Jan 27 21:50:22 2003
;; CAL version 5.31 of Sun Jan 26 13:13:13 2003
;; CAL version 5.30 of Fri Jan 17 18:32:24 2003
;; CAL version 5.29 of Thu Jan 16 18:45:23 2003
;; CAL version 5.28 of Wed Jan 15 13:54:42 2003
;; CAL version 5.27 of Tue Jan 14 23:28:22 2003
;; CAL version 5.26 of Sat Jan  4 12:03:04 2003
;; CAL version 5.25 of Fri Jan  3 11:52:55 2003
;; CAL version 5.24 of Wed Jan  1 16:04:52 2003
;; CAL version 5.23 of Fri Dec 13 23:16:48 2002
;; CAL version 5.22 of Sun Dec  8 16:44:54 2002
;; CAL version 5.21 of Sun Dec  1 21:25:13 2002
;; CAL version 5.20 of Thu Nov 28 13:43:25 2002
;; CAL version 5.19 of Tue Nov 26 21:46:53 2002
;; CAL version 5.18 of Tue Nov 26 00:20:35 2002
;; CAL version 5.17 of Sun Nov 24 19:07:57 2002
;; CAL version 5.16 of Fri Nov 22 15:34:05 2002
;; CAL version 5.15 of Sun Nov 17 11:27:51 2002
;; CAL version 5.14 of Mon Nov 11 16:15:00 2002
;; CAL version 5.13 of Wed Nov  6 11:38:26 2002
;; CAL version 5.12 of Tue Nov  5 11:19:22 2002
;; CAL version 5.11 of Mon Nov  4 21:31:17 2002
;; CAL version 5.10 of Wed Oct 30 11:46:20 2002
;; CAL version 5.9 of Mon Oct 28 17:12:56 2002
;; CAL version 5.8 of Wed Sep 25 21:49:41 2002
;; CAL version 5.7 of Thu Sep 19 05:46:49 2002
;; CAL version 5.6 of Thu Sep  5 00:13:41 2002
;; CAL version 5.5 of Sun Sep  1 23:58:54 2002
;; CAL version 5.4 of Thu Aug 29 20:35:37 2002
;; CAL version 5.3 of Tue Aug 27 21:20:42 2002
;; CAL version 5.2 of Mon Aug 26 09:21:54 2002
;; CAL version 5.1 of Sat Aug 17 16:42:34 2002
;; CAL version 5.0 of Tue Jul  9 15:54:18 2002
;; CAL version 4.9 of Mon Jun 25 11:25:54 2001
;; CAL version 4.8 of Mon Jun 11 13:53:53 2001
;; CAL version 4.7 of Thu Jun  7 13:04:15 2001
;; CAL version 4.6 of Tue Jun  5 10:35:15 2001
;; CAL version 4.5 of Mon May 21 10:48:49 2001
;; CAL version 4.4 of Wed Apr 25 10:56:12 2001
;; CAL version 4.3 of Sat Apr 21 01:03:38 2001
;; CAL version 4.2 of Mon Apr 16 14:34:01 2001
;; CAL version 4.1 of Fri Apr 13 15:32:18 JST 2001
;; CAL version 3.27 of Fri Feb  9 17:45:22 2001
;; CAL version 3.26 of Tue Jan 30 17:12:58 2001
;; CAL version 3.25 of Sat Jan 20 10:21:36 2001
;; CAL version 3.24 of Wed Jan 10 10:40:01 2001
;; CAL version 3.23 of Tue Jan  2 17:33:42 2001
;; CAL version 3.22 of Sat Dec 23 14:23:30 2000
;; CAL version 3.21 of Tue Dec 12 20:53:06 2000
;; CAL version 3.20 of Sun Dec 10 20:11:50 2000
;; CAL version 3.19 of Thu Dec  7 22:58:17 2000
;; CAL version 3.18 of Wed Dec  6 12:14:14 2000
;; CAL version 3.17 of Tue Dec  5 22:54:02 2000
;; CAL version 3.16 of Sun Dec  3 15:55:32 2000
;; CAL version 3.15 of Wed Nov 22 14:28:39 2000
;; CAL version 3.14 of Sun Nov 19 12:41:11 2000
;; CAL version 3.13 of Sat Nov 18 12:32:49 2000
;; CAL version 3.12 of Fri Nov 17 17:49:46 2000
;; CAL version 3.11 of Thu Nov 16 10:53:42 2000
;; CAL version 3.10 of Wed Nov 15 21:31:53 2000
;; CAL version 3.9 of Mon Nov 13 10:57:27 2000
;; CAL version 3.8 of Sun Nov 12 21:27:27 2000
;; CAL version 3.7 of Wed Nov  1 10:28:31 2000
;; CAL version 3.6 of Fri Oct 27 11:37:14 2000
;; CAL version 3.5 of Thu Oct 26 10:54:44 2000
;; CAL version 3.4 of Wed Oct 25 21:54:35 2000
;; CAL version 3.3 of Tue Oct 24 16:54:10 2000
;; CAL version 3.2 of Sat Oct 14 21:47:40 2000
;; CAL version 3.1 of Fri Oct 13 16:16:02 2000
;; CAL version 2.14 of Sat Feb 12 14:39:38 2000
;; CAL version 2.13 of Mon Dec 20 21:34:57 1999
;; CAL version 2.12 of Sat Dec 18 16:24:44 1999
;; CAL version 2.11 of Mon Dec 13 18:04:08 1999
;; CAL version 2.10 of Sun Dec 12 13:18:13 1999
;; CAL version 2．09 of Sat Dec  4 12:42:38 1999
;; CAL version 2.08 of Fri Dec  3 16:43:41 1999
;; CAL version 2.07 of Thu Dec  2 16:16:34 1999
;; CAL version 2.06 of Sun Nov 28 14:51:06 1999
;; CAL version 2.05 of Thu Nov  4 11:09:11 1999
;; CAL version 2.04 of Fri Mon Oct 25 18:30:18 1999
;; CAL version 2.03 of Fri Oct 22 15:47:43 1999
;; CAL version 2.02 of Sat Oct 16 16:05:30 1999
;; CAL version 2.01 of Wed Oct 13 23:35:10 1999
;; CAL version 1.27 of Mon Feb 15 00:10:35 1999
;; CAL version 1.26 of Sat Jan 30 19:51:52 1999
;; CAL version 1.25 of Thu Jan 28 00:14:38 1999
;; CAL version 1.24 of Sat Jan 23 18:19:07 1999
;; CAL version 1.23 of Mon Jan 18 14:19:48 1999
;; CAL version 1.22 of Wed Jan 13 22:32:56 1999
;; CAL version 1.21 of Mon Jan 11 23:45:13 1999
;; CAL version 1.20.3 of Tue Dec 29 15:02:18 1998
;; CAL version 1.20.2 of Mon Dec 28 15:09:26 1998
;; CAL version 1.19: Wed Dec 16 22:42:29 1998
;; CAL: Version 1.17 of November 18, 1998.
;; CAL: Version 1.16 of November 17, 1998.
;; CAL: Version 1.15 of November 16, 1998.
;; CAL: Version 1.14 of November 14, 1998.
;; CAL: Version 1.13 of October 30, 1998.
;; CAL: Version 1.12 of October 30, 1998.
;; CAL: Version 1.11 of October 29, 1998.
;; CAL: Version 1.10 of October 27, 1998.
;; CAL: Version 1.09 of October 26, 1998.
;; CAL: Version 1.08 of October 26, 1998.
;; CAL: Version 1.07 of October 25, 1998.
;; CAL: Version 1.06 of October 23, 1998.
;; CAL: Version 1.05 of October 22, 1998.
;; CAL: Version 1.04 of October 21, 1998.
;; CAL: Version 1.03 of October 19, 1998.
;; CAL: Version 1.02 of October 17, 1998.

(eval-when-compile
  (require 'parser (concat cal-dir "parser/parser.elc")) 
  (require 'nf (concat cal-dir "nf/nf.elc")))

(defun cal-call-process (program &rest args)
  (or (equal 
       (condition-case nil
	   (apply 'call-process program nil nil nil args)
	 (error (cal-report-fatal-error program args)))
       0)	  
      (cal-report-fatal-error program args)))

(defun cal-report-fatal-error (program args)
  (error "プログラム %s %s の実行に失敗しました. 教官かTAに連絡してください."
	 program args))

;; the above two functions must be defined before loading cal-site.el

(let ((el-file (concat cal-dir "cal-mode/cal-site.el"))
      (elc-file (concat cal-dir "cal-mode/cal-site.elc")))
  (if (file-exists-p elc-file)
      (load elc-file nil t t)
    (load el-file nil t t)))

(defvar cal-user-id nil)  ;; user が問1に解答すると set される
(defvar cal-solved-list nil)
(defvar *csl* nil) ;; internal form of cal-solved-list
(defvar cal-thm-list nil)
(defvar cal-thm-str-list nil)
(defvar cal-def-list nil)
(defvar cal-def-str-list nil)
(defvar cal-game-ops nil) ;; ops for defined predicates and theorems
(defvar cal-no-of-problems nil)
(defvar cal-game-dirs nil)
(defvar cal-saved-game-dirs nil)
(defvar cal-saved-current-game nil)
(defvar cal-language "japanese")

(defconst cal-deriv-str nil
  "The derivation string most recently checked.")

(defvar cal-overlay nil)
(defvar cal-overlay2 nil)
;;(defvar cal-ignore-error nil)
(defvar cal-demo-dir (concat cal-dir "examples/"))
(setq cal-demo-on nil)
(setq cal-demo-command nil)

;; for parsing
(defvar cal-meta nil
  "Set CAL-META to t when parsing at meta-level.")

;; for TeX
(defvar META-VARS nil)
(defvar ITALIC nil)
(defvar RULE-ARG nil)

;; customizable variables

(defvar cal-indent-unit 2)
(defvar cal-expand-long nil)

;; global variables

(setq cal-exit-flag nil)
(setq cal-prompt-count 0)
(setq cal-history-count 0)
(setq cal-partial-input "")
(setq cal-old-arg "")
;; the command string yet to be processed.
(setq cal-current-command nil)
(setq cal-no-of-news nil)
(setq cal-wild-card-op '((op "WILD_CARD_OP")))
(setq cal-eval-value nil)
(setq cal-current-game nil)
(setq cal-fontify nil)
;;(setq cal-games-in-play nil)


;; constants

(defconst cal-prompt-pattern "^CAL[^ ]* <%s>")
(defconst cal-deftokens-string "tokens[")
(defconst cal-defsyntax-string "syntax[")
(defconst cal-defrules-string "rules[")

;; load necessary files silently.

(defvar cal-test-run nil)

(if cal-test-run
    (progn
      (load (concat cal-dir "cal-mode/cal-develop.el") nil t t)
      (load (concat cal-dir "cal-mode/cal-util.el") nil t t)
      (if cal-use-w3m
	  (load (concat cal-dir "cal-mode/cal-w3m.el") nil t t)
	(load (concat cal-dir "cal-mode/cal-local.el") nil t t))
      (load (concat cal-dir "cal-mode/cal-exp.el") nil t t)
      (load (concat cal-dir "cal-mode/cal-games.el") nil t t)
      (load (concat cal-dir "cal-mode/cal-tex.el") nil t t)
      (load (concat cal-dir "parser/parser.elc") nil t t)
      (load (concat cal-dir "nf/nf-exp.el") nil t t)
      (load (concat cal-dir "nf/nf.el") nil t t)
      (unless (string= cal-language "japanese")
	(load (concat cal-dir "cal-mode/cal-lang.el") nil t t))
      )
  (load (concat cal-dir "cal-mode/cal-util.elc") nil t t)
  (if cal-use-w3m
      (load (concat cal-dir "cal-mode/cal-w3m.elc") nil t t)
    (load (concat cal-dir "cal-mode/cal-local.elc") nil t t))
  (load (concat cal-dir "cal-mode/cal-exp.elc") nil t t) 
  (load (concat cal-dir "cal-mode/cal-games.elc") nil t t)
  (load (concat cal-dir "cal-mode/cal-tex.elc") nil t t)
  (load (concat cal-dir "parser/parser.elc") nil t t)
  (load (concat cal-dir "nf/nf-exp.elc") nil t t)
  (load (concat cal-dir "nf/nf.elc") nil t t)
  (unless (string= cal-language "japanese")
    (load (concat cal-dir "cal-mode/cal-lang.elc") nil t t))
  )

;; setup the logic mode

(defvar cal-mode-map (make-sparse-keymap)
  "Keymap used in logic.")

(define-key cal-mode-map "/d" 'cal-defeq-symbol)
(define-key cal-mode-map "/e" 'cal-in)
(define-key cal-mode-map "/i" 'cal-imp)
(define-key cal-mode-map "/a" 'cal-and)
(define-key cal-mode-map "/o" 'cal-or)
(define-key cal-mode-map "/A" 'cal-All)
(define-key cal-mode-map "/E" 'cal-Exists)
(define-key cal-mode-map "/f" 'cal-false)
(define-key cal-mode-map "/l" 'cal-lambda)
(define-key cal-mode-map "/n" 'cal-not)
(define-key cal-mode-map "/p" 'cal-proves)
(define-key cal-mode-map "/u" 'cal-univ)
(define-key cal-mode-map "/y" 'cal-yields)
(define-key cal-mode-map "/Y" 'cal-Yields)
(define-key cal-mode-map "/<" 'cal-open-qq)
(define-key cal-mode-map "/>" 'cal-close-qq)
(define-key cal-mode-map "//" 'cal-slash)
(define-key cal-mode-map "/?" 'cal-key-help)
(define-key cal-mode-map "/ " 'cal-blank)
(define-key cal-mode-map "/0" 'cal-undo)
(define-key cal-mode-map "/\C-m" 'cal-submit)
(define-key cal-mode-map "\C-m" 'cal-return)
(define-key cal-mode-map " " 'cal-space)
(define-key cal-mode-map "\t" 'cal-completion)
;; (define-key cal-mode-map ":" 'cal-colon)
(define-key cal-mode-map "\[" 'cal-open-bracket)
(define-key cal-mode-map "\]" 'cal-close-bracket)
(define-key cal-mode-map "\{" 'cal-open-brace)
(define-key cal-mode-map "\}" 'cal-close-brace)
(define-key cal-mode-map "\(" 'cal-open-paren)
(define-key cal-mode-map "\)" 'cal-close-paren)
(define-key cal-mode-map "\<" 'cal-open-angle)
(define-key cal-mode-map "\>" 'cal-close-angle)

(defvar cal-use-arrow-key nil)

(if cal-use-arrow-key
    (progn
      (define-key cal-mode-map [up] 'cal-history-up)
      (define-key cal-mode-map [down] 'cal-history-down)
      (define-key cal-mode-map [left] 'cal-toggle-input)))

(defvar cal-mode-syntax-table nil "")

(defun cal-set-syntax ()
  (setq cal-mode-syntax-table (make-syntax-table))
  (modify-syntax-entry ?_ "w   " cal-mode-syntax-table)
  (modify-syntax-entry ?  "    " cal-mode-syntax-table)
  (modify-syntax-entry ?\t "    " cal-mode-syntax-table)
  (modify-syntax-entry ?\n ">   " cal-mode-syntax-table)
  (modify-syntax-entry ?\^m ">   " cal-mode-syntax-table)
  (modify-syntax-entry ?\( "()  " cal-mode-syntax-table)
  (modify-syntax-entry ?\) ")(  " cal-mode-syntax-table)
  (modify-syntax-entry ?\{ "(}  " cal-mode-syntax-table)
  (modify-syntax-entry ?\} "){  " cal-mode-syntax-table)
  (modify-syntax-entry ?\[ "(]  " cal-mode-syntax-table)
  (modify-syntax-entry ?\] ")[  " cal-mode-syntax-table)
  (modify-syntax-entry ?\< "(>  " cal-mode-syntax-table)
  (modify-syntax-entry ?\> ")<  " cal-mode-syntax-table)
  (modify-syntax-entry ?\; ". 12" cal-mode-syntax-table))

(defun cal ()
  (interactive)
  (message "test")
  (if (get-buffer "*cal*")
      (progn
	(switch-to-buffer "*cal*")
	(delete-other-windows))
    ;; we first call cal-news to check if the news file is downloadable
    (if (cal-get-news)
	(progn
	  (cal-mode)
	  (switch-to-buffer "*cal*")
	  (delete-other-windows))
      ;; report error (without actually calling error)
      (message "ファイルのダウンロードに失敗しました! 教官かTAに連絡してください．")
      (ding))
    ))

(defun cal-initial-setup (id) t)
;; comment-out
;; (defun cal-initial-setup (id)
;;   "Initial setup for CAL. Return T or report error."
;;   (if cal-use-w3m
;;       (let (result)
;; 	(with-temp-file
;; 	    cal-temp-file
;; 	  ;;(insert "name=" (user-login-name) "&passwd=" id "&SUBMIT=hoge")
;; 	  (insert "name=" (getenv "USER") "&passwd=" id "&SUBMIT=hoge")
;; 	  )
;; 	(with-temp-buffer
;; 	  (apply 'call-process cal-w3m-command nil (current-buffer) nil
;; 		 (append cal-w3m-command-arguments
;; 			 (list "-cookie" "-post" 
;; 			       cal-temp-file cal-welcome-url)))
;; 	  (goto-char (point-min))
;; 	  (setq result (if (search-forward "Received" nil t) t nil)))
;; 	(cal-call-process cal-my-rm cal-temp-file)
;; 	(or result
;; 	    (error "登録したデータと一致しません．教官か TA に連絡してください．")))
;;     t))

(defun cal-exit ()
  "Exit from cal-mode."
  (let (;; inhibit quit!
	(inhibit-quit t)
	(time (current-time-string))
	record-string)
    (save-excursion
      (if *csl*
	  ;; we save the log buffer and upload record file etc.
	  ;; only when *csl* is non-nil
	  (progn
	    (set-buffer (get-buffer-create " *CALLOG*"))
	    (goto-char (point-max))
	    (unless (bolp) (insert "\n"))
	    (insert (format "-----\nCAL session terminated\nat: %s\n"
			    (current-time-string)))
	    (write-region (point-min) (point-max) 
			  (concat my-cal-session-log-file
				  (int-to-string cal-session-count))
			  nil 0)
	    (when cal-session-log-file
	      (let ((file (concat cal-session-log-file
				  (int-to-string cal-session-count))))
		(cal-upload file cal-upload-url)))
	    ;; we don't send mail anymore
	    ;;(cal-mail-to-callog
	    ;;(format "CAL session Log [%s]" cal-session-count)
	    ;;(buffer-substring (point-min) (point-max)))
	    (erase-buffer)
	    ;; just for sure
	    (sit-for 0.1)
	    ;; save newly proved theorems
	    (let ((list cal-new-thm-list) thm name file)
	      (while list
		(setq thm (car list))
		(setq name (car thm))
		(setq file (concat cal-thm-dir name))
		(erase-buffer)
		(insert "'")
		(cal-print-tree thm 2)
		(insert "\n")
		(write-region (point-min) (point-max) file nil 0)
		(sit-for 0.1)
		(cal-call-process cal-my-chmod "600" file)
		(setq list (cdr list))))
	    (erase-buffer)
	    ;; just for sure
	    (sit-for 0.1)
	    ;; now insert data for .cal
	    (if cal-user-id
		(insert
		 (format
		  "(setq cal-user-id \"%s\")\n"
		  cal-user-id)))
	    (insert
	     (format
	      "(setq cal-session-count %s)\n"
	      cal-session-count))
	    (insert
	     (format
	      "(setq cal-solved-list '%s)\n"
	      *csl*))
	    (if cal-current-game
		(insert
		 (format
		  "(setq cal-current-game \"%s\")\n"
		  cal-current-game)))
	    (insert "(setq cal-def-list\n      '(\n")
	    (let ((list cal-def-list))
	      (while list
		(cal-print-tree (car list) 2)
		(insert "\n")
		(setq list (cdr list))))
	    (insert "))\n")
	    (insert "(setq cal-def-str-list\n      '(\n")
	    (let ((list cal-def-str-list))
	      (while list
		(cal-print-tree (car list) 2)
		(insert "\n")
		(setq list (cdr list))))
	    (insert "))\n")
	    (insert "(setq cal-thm-list\n      '(\n")
	    (let ((list cal-thm-list))
	      (while list
		(cal-print-tree (car list) 2)
		(insert "\n")
		(setq list (cdr list))))
	    (insert "))\n")
	    (insert "(setq cal-thm-str-list\n      '(\n")
	    (let ((list cal-thm-str-list))
	      (while list
		(cal-print-tree (car list) 2)
		(insert "\n")
		(setq list (cdr list))))
	    (insert "))\n")
	    (insert
	     (format
	      "(setq cal-news-list '%s)\n"
	      cal-news-list))
	    (cal-encrypt-buffer)
	    (write-region (point-min) (point-max) cal-record-file nil 0) 
	    (sit-for 0.1)
	    (cal-upload cal-record-file cal-upload-url)
	    ))) 
    (if (get-buffer " *CALLOG*") (kill-buffer " *CALLOG*"))
    (if (get-buffer " *CALMAIL*") (kill-buffer " *CALMAIL*"))
    (if (get-buffer " *PROBLEMS*") (kill-buffer " *PROBLEMS*"))
    (if (get-buffer " *ANSWERS*") (kill-buffer " *ANSWERS*"))
    (if (get-buffer " *HELP*") (kill-buffer " *HELP*"))
    (if (get-buffer " *NEWS*") (kill-buffer " *NEWS*"))
    (if (get-buffer " *CALWORK*") (kill-buffer " *CALWORK*"))
    (if (get-buffer " *RECORD*") (kill-buffer " *RECORD*"))
    (if (get-buffer " *MYRECORD*") (kill-buffer " *MYRECORD*"))
    (end-of-line)
    (insert "\nBye,")
    (sit-for 1)
    (insert "\nBye!\n")
    (sit-for 0.5)
    (message "")
    (if (get-buffer " *CALMAIL*") (kill-buffer " *CALMAIL*"))
    (setq cal-exit-flag t
	  cal-session-count 0
	  cal-solved-list nil
	  cal-current-game nil
	  *csl* nil
	  cal-def-list nil
	  cal-thm-list nil
	  cal-game-ops nil)
    (set-buffer-modified-p nil)
    (kill-buffer (current-buffer))))

;; some useful functions

(defmacro cal-error-to-nil (form)
  "Evaluate FORM and convert error to nil."
  `(condition-case nil
       ,form
     (error nil)))

(defun cal-set-current-game (game)
  "Set cal-current-game to GAME."
  (let ((ops (second (assoc game cal-game-ops))))
    (while ops 
      (parser-extend-prim-exp-pat (first ops))
      (setq ops (cdr ops))) 
    (setq cal-current-game game)))

(defun cal-update-list (list key value)
  "Update LIST by adding VALUE to KEY in the LIST.  LIST must be given
by its name."
  (let ((pre nil)
	(post (eval list))
	(cont t))
    (while (and post cont)
      (let* ((item (first post))
	     (rest (cdr post))
	     (k (first item))
	     (v (second item)))
	(if (string= k key)
	    ;; found the key!
	    (progn
	      (set list (append pre (list (list key (cons value v))) rest))
	      (setq cont nil))
	  (setq pre (append pre (list item))
		post (cdr post)))))
    (when cont
      ;; create a new key-value and add it to LIST
      (set list (cons (list key (list value)) (eval list))))))

(defun cal-split-str (str pat &optional top)
  "Split STR containing a PAT into two parts.  If TOP, PAT within
a parenthesis will be ignored.  For example, (cal-split-str \"ab(c,d),ef\" \",\")
returns (\"ab(c\" \"d),ef\") if TOP is nil, and returns (\"ab(c,d)\" \"ef\") if
TOP is non-nil."
  (if (cal-string-search pat str top)
      (list (substring str 0 (1- (match-beginning 0)))
	    (substring str (1- (match-end 0))))
    nil))

(defun cal-split-list (list key)
  "Split LIST into three parts with a list whose car is KEY becomes
the middle part.  LIST is a list of lists."
  (let ((cont t)
	(pre nil)
	(middle nil)
	(post list))
    (while (and cont post)
      (let* ((item (first post))
	     (k (first item)))
	(if (equal key k)
	    ;; found it
	    (setq middle item
		  post (cdr post)
		  cont nil)
	  (setq pre (append pre (list item))
		post (cdr post)))))
    (list pre middle post)))

(defun cal-convert-hypj-to-condj (str)
  "Convert STR, which is a hypothetical judgment, into conditional
judgment."
  (let* ((pair (cal-split-str str "├"))
	 (hyp (first pair))
	 (conc (second pair))
	 (pre nil))
    (while (cal-split-str hyp "::")
      (setq hyp (second (cal-split-str hyp "::")))
      (if hyp
	  ;; we found an assumption
	  (let* ((oldhyp hyp)
		 (item (cal-split-str hyp "," t))
		 (head (first item))
		 (hyp (second item)))
	    (if head
		(setq pre (append pre (list head)))
	      (setq pre (append pre (list oldhyp)))
	      ))))
    (list pre conc)))

(defun cal-string-search (pat str &optional top)
  "Search PAT in STR, and returns the list of postions surrounding PAT.
If TOP, PAT within a parenthesis will be ignored."
  (with-temp-buffer
    (insert str)
    (goto-char (point-min))
    (if top
	(let ((found nil) p)
	  (while (and (not found) 
		      ;; search PAT only if not FOUND
		      (search-forward pat nil t))
	    (save-excursion
	      (insert ")")
	      (setq p (point))
	      (cal-error-to-nil (backward-sexp 1))
	      (if (= p (point))
		  ;; point is not inside a paren
		  (setq found t)
		(goto-char p))
	      (delete-char -1)))
	  (if found
	      (list (match-beginning 0) (match-end 0))
	    nil))
      (if (search-forward pat nil t)
	  (list (match-beginning 0) (match-end 0))
	nil))))

(defun cal-deriv-rules (deriv)
  "Compute the list of rules used in DERIV."
  (cond ((exp-varref-p deriv) nil)
	((exp-CD-p deriv)
	 (let ((rule (exp-CD-rule-name deriv))
	       (derivs (exp-CD-subderivs deriv)))
	   (cons rule (cal-derivs-rules derivs))))
	((exp-HD-p deriv) (cal-deriv-rules (exp-HD-body deriv)))
	((exp-UD-p deriv) (cal-deriv-rules (exp-Abs-body deriv)))))

(defun cal-derivs-rules (derivs)
  "Auxiliary function for CAL-DERIV-RULES."
  (let ((result nil))
    (while derivs
      (setq result (append (cal-deriv-rules (car derivs)) result)
	    derivs (cdr derivs)))
    result))

(defun cal-check-user-id (str)
  "check if STR matches the required pattern."
  (if (and 
       (string-match
	"[^,]+,\\(199[0-9]\\|20[0-9][0-9]\\),\\([0-9][0-9][0-9][0-9]\\),[^,]+" 
	str)
       (= (match-end 0) (length str)))
      (if (cal-initial-setup (substring str (match-beginning 2) (match-end 2)))
	  (progn
	    (setq cal-user-id str)
	    t)
	(error "解答の文字列が指定された形式になっていません!"))))

(defun cal-current-prompt ()
  "current prompt string."
  (if cal-current-game
      (format "CAL:%s <%s>" cal-current-game cal-prompt-count)
    (format "CAL <%s>" cal-prompt-count)))

(defun cal-increment-prompt-count ()
  "increment prompt count and record it in log file.
also, increment cal-history-count."
  (setq cal-prompt-count (1+ cal-prompt-count)
	cal-history-count cal-prompt-count
	cal-partial-input ""
	cal-demo-command nil
	)
  ;; reset cal-current-command
  (setq cal-current-command nil)
  (cal-insert-prompt (cal-current-prompt))
  (insert " ")
  (save-excursion
    (set-buffer (get-buffer-create " *CALLOG*"))
    (goto-char (point-max))
    (unless (bolp) (insert "\n"))
    (insert (format "-----\n%s <%s> %s\n"
		    cal-current-game
		    cal-prompt-count
		    (current-time-string)))))

(defun cal-error (message)
  (if (> (string-width message) 77)
      (progn
	(set-buffer "*cal*")
	(goto-char (point-max))
	(or (bolp) (insert "\n"))
	(insert ";; " message)
	(error ""))
    (error message)))

(defun cal-report-error (message)
  ;;(cal-mail-to-kougi "Implementation Error!" message)
  (error "%s: 実装のエラーです. 教官かTAに連絡してください." message))

(defun cal-insert-lines (str)
  (let (p q)
    (goto-char (point-max))
    (cal-skip-back)
    (delete-region (point) (point-max))
    (setq p (point))
    (cal-insert str)
    (setq q (point))
    (sit-for 0) ;; this is necessary to force recenter!
    (or (pos-visible-in-window-p p)
	(progn
	  (setq q (point))
	  (goto-char p)
	  (recenter 0)
	  (goto-char q)))
    ))

(defun cal-looking-at (pattern)
  (let ((case-fold-search nil)) 
    (if (posix-looking-at pattern)
	(save-excursion
	  (goto-char (match-end 0))
	  (skip-chars-forward " \t")
	  ;; now, if we are at eol or following char is \[, then we 
	  ;;are exactly looking at PATTERN
	  (or (= (following-char) ?\[) (eolp)))
      nil)))

(defun cal-skip ()
  (let ((p (point)))
    (skip-chars-forward " \t\n")
    (if (eobp) (delete-region p (point)))))

(defun cal-skip-back ()
  (skip-chars-backward " \t\n"))

(defun cal-backward-word ()
  "backward a word without going beyond an open paren.
this function is called always from within box."
  (let (l p)
    (save-excursion
      (if (setq l (cal-find-open-paren))
	  (setq p (1+ (second l)))
	(search-backward "\[" nil t)
	(setq p (1+ (point)))))
    (backward-word 1)
    (goto-char (max (point) p))))

(defun cal-insert (&rest strings)
  (let (p)
    (end-of-line)
    (when (not (bolp)) (insert "\n"))
    (setq p (point))
    (apply (function insert) strings)
    (when (not (bolp)) (insert "\n"))
    (add-text-properties p (point)
		       '(face cal-insert-face))))

(defun cal-insert-prompt (&rest strings)
  (let (p)
    (unless (bolp)
      (end-of-line)
      (insert "\n"))
    (setq p (point))
    (apply (function insert) strings)
    (add-text-properties p (point)
			 (if cal-demo-on
			     '(read-only t
					 face cal-demo-face
					 rear-nonsticky (face read-only))
			   '(read-only t
				       face cal-prompt-face
				       rear-nonsticky (face read-only))))))

(defun cal-insert-string (string)
  "Insert STRING with CAL-INSERT-FACE"
  (let (p)
    (setq p (point))
    (insert string)
    (add-text-properties p (point)
		       '(face cal-insert-face
			      rear-nonsticky t))))

(defface cal-variable-face
  '((((type tty pc) (class color) (background light)) (:foreground "blue"))
    (((class color) (background light)) (:foreground "blue"))
    (t (:bold t :italic t)))
  "CAL face for variables")

(defface cal-insert-face
  '((((type tty pc) (class color) (background light)) (:foreground "Firebrick"))
    (((class color) (background light)) (:foreground "Firebrick"))
    (t (:bold t :italic t)))
  "CAL face for inserting text")

(defface cal-prompt-face
  '((((type tty pc) (class color) (background light)) (:foreground "ForestGreen"))
    (((class color) (background light)) (:foreground "ForestGreen"))
    (t (:bold t :italic t)))
  "CAL face for inserting prompt")

(defface cal-demo-face
  '((((type tty pc) (class color) (background light)) (:foreground "Purple"))
    (((class color) (background light)) (:foreground "Purple"))
    (t (:bold t :italic t)))
  "CAL face for inserting prompt when cal-demo is on")

(defface cal-error-face
  '((((type tty pc) (class color) (background light)) (:foreground "Red"))
    (((class color) (background light)) (:foreground "Red"))
    (t (:bold t :italic t)))
  "CAL face for showing errors")

(defface cal-error2-face
  '((((type tty pc) (class color) (background light)) (:foreground "Blue"))
    (((class color) (background light)) (:foreground "Blue"))
    (t (:bold t :italic t)))
  "another CAL face for showing errors")

(defun cal-split (string)
  "split STRING separated by - into two parts.
E.g., 「」 -> \(\), 「abc」 -> \(abc\) 「abc-」 -> \(abc nil\),
 「-xyz」 -> (nil xyz), 「abc-xyz」 -> \(abc, xyz\), 「-」 -> \(nil nil\)"
  (let (p)
    (if (string= string "")
	nil
      (save-excursion
      (set-buffer (get-buffer-create " *CALWORK*"))
      (erase-buffer)
      (insert string)
      (goto-char (point-min))
      (if (search-forward "-" nil t)
	  (list (buffer-substring
		 (point-min)
		 (save-excursion
		   (backward-char 1)
		   (skip-chars-backward " \t")
		   (point)))
		(buffer-substring
		 (save-excursion
		   (skip-chars-forward " \t")
		   (point))
		 (point-max)))
	(list string))))))

(defun cal-substring (str)
  "compute substring determined by the interval (cal-split STR).
also returns the start and end indices.  so this function returns
 (STRING START END)."
  (let ((list (cal-split str))
	beg end
	min max
	str1 str2
	m)
    (goto-char (point-max))
    (re-search-backward "-----\n\\[\\([0-9]*\\)\\]" nil t)
    (setq m (buffer-substring (match-beginning 1) (match-end 1)))
    (if (null list) (setq list (list m m)))
    (if (= (length list) 1)
	(setq list (cons (car list) list)))
    ;; now list has two elements. we first normalize list
    (let ((i (car list)) (j (second list)))
      (setq list
	    (list (if (string= i "") "1" i)
		  (if (string= j "") m j))))
    (goto-char (point-min))
    (setq str1 (car list)
	  str2 (second list))
    (if (string= str1 "")
	(progn
	  (re-search-forward "^-----\n")
	  (setq beg (point)))
      (if (search-forward (concat "-----\n[" str1 "]") nil t)
	  (progn
	    (beginning-of-line)
	    (setq beg (point)))
	(error "番号 %s の項目はありません!" str1)))
    (if (string= str2 "")
	(progn
	  (goto-char (point-max))
	  (search-backward "\n-----")
	  (setq end (1+ (point))))
      (goto-char (point-min))
      (if (search-forward (concat "-----\n[" str2 "]") nil t)
	  (progn
	    (re-search-forward "^-----\n")
	    (setq end (match-beginning 0)))
	(error "番号 %s の項目はありません!" str2)))
    (setq min (string-to-int str1))
    (setq max (string-to-int str2))
    (if (> min max)
	(error "区間の指定が正しくありません!"))
    (list (buffer-substring beg end) min max)))

(defun cal-max-no ()
  "compute the last item number of the current buffer"
  (save-excursion
    (goto-char (point-max))
    (re-search-backward "-----\n\\[\\([0-9]*\\)\\]" nil t)
    (string-to-int
     (buffer-substring (match-beginning 1) (match-end 1)))))

(defun cal-cons (item list)
  "cons ITEM and LIST, if ITEM is not in LIST"
  (if (member item list)
      list
    (cons item list)))

(defun cal-print-tree (tree n)
  "Print TREE.  If n>0, then insert newline for each element of
a list and indent properly."
  (cond ((listp tree)
	 (insert "(")
	 (while tree
	   (cal-print-tree (car tree) (max 0 (1- n)))
	   (setq tree (cdr tree))
	   (when tree
	     (if (> n 0)
		 (progn
		   (insert "\n")
		   (let ((k n))
		     (while (> k 0)
		       (insert "    ")
		       (setq k (1- k)))))
	       (insert " "))))
	 (insert ")"))
	((or (symbolp tree) (integerp tree))
	 (insert (format "%s" tree)))
	((stringp tree)
	 ;; use format to print ?\ correctly
	 (insert (format "%S" tree)))
	(t (cal-error "cal-print-tree")))
  )

(defun cal-check-lists (a b)
  "check if two lists are equal modulo order."
  (let ((c nil) (d nil))
    (while a
      (if (member (car a) c)
	  (error "パラメータに変数 %s が2回以上出現してはいけません!"
		 (second (car a)))
	(setq c (cons (car a) c))
	(setq a (cdr a))))
    ;; now c is a copy of a without duplication
    (while b
      (if (not (member (car b) d))
	  (setq d (cons (car b) d)))
      (setq b (cdr b)))
    ;; now d is a copy of b without duplication
    (if (< (length c) (length d)) (error "パラメータの変数が不足しています!"))
    (if (> (length c) (length d)) (error "パラメータの変数が多すぎます!"))
    (while c
      (if (member (car c) d)
	  (setq c (cdr c))
	(error "仮定にない変数 %s はパラメータに使えません!"
	       (second (car c)))))))

(defun cal-get-vars (list)
  "make list of variables out of a hyp-seq."
  (let ((v nil))
    (while list
      (setq v (cons (second (car list)) v)
	    list (cdr list)))
    v))

(defun cal-const-p (string)
  "check if STRING is a constant."
  (let ((word-seq (LexString string)))
    (and (listp word-seq)
	 (= (length word-seq) 1)
	 (let ((item (car word-seq)))
	   (and (listp item)
		(= (length item) 2)
		(eq 'op (car item)))))))

(defun cal-load-game (game)
  "Load GAME file. Be sure to follow the convention to use the same
name for both the name of the game and name of the file which defines
the game."
  (let ((PEP nil)
	(cal-meta t)
	(name-of-the-game game))
    ;; PrimExpPat is set by loading the following file
    (load-file (cal-game-file game))
    (setq PrimExpPat PEP)))

(defun cal-parse-defs (game &optional syntax-only)
  "Parse current buffer as definitions of a game.  If everything goes well, 
the function just returns nil. As a side-effect PrimExpPat is reset by 
deftokens.  NAME-OF-THE-GAME is bound to GAME so that it will be
accessble from functions called inside the body of this function.
If optional SYNTAX-ONLY is T, only tokens and syntax part will be
parsed.  This function is called only from CAL-DEFGAME, when a new game
is defined or it is modified."
  (let (p q (name-of-the-game game) (rule-list nil)
	  ;; set CAL-META to T
	  (cal-meta t))
    (save-excursion
      (set-buffer (get-buffer-create " *GAMECOMPILE*"))
      (erase-buffer))
    (goto-char (point-min))
    ;; first, we process the token part
    (if (search-forward cal-deftokens-string nil t)
	(progn
	  (setq p (point))
	  (backward-char 1)
	  (condition-case condition
	      (forward-sexp)
	    (error
	     (error "対応する閉括弧「]」がありません")))
	  (ParseString (buffer-substring-no-properties p (1- (point)))
		       'deftokens (1- p)))
      ;; we just use default PrimExpPat for PEP
      (setq PEP
	    (concat CommonConstExp "\\|" CommonOpExp "\\|" CommonOpenExp 
		    "\\|" CommonCloseExp))
      (save-excursion
	(set-buffer " *GAMECOMPILE*")
	(insert "(setq PEP\n"
		"     (concat CommonConstExp \"\\\\|\" CommonOpExp \"\\\\|\" CommonOpenExp\n"
		"     \"\\\\|\" CommonCloseExp))")
	)
      )
    ;; next, we process the syntax defs
    (when (search-forward cal-defsyntax-string nil t)
      (setq p (point))
      (backward-char 1)
      (condition-case condition
	  (forward-sexp)
	(error
	 (error "対応する閉括弧「]」がありません")))
      ;; parse the defclasses by using PEP as PrimExpPat
      (ParseString (buffer-substring-no-properties p (1- (point)))
		   'defclasses (1- p)))
    ;; from now on, we use new value of PrimExpPat
    (setq PrimExpPat PEP)
    (save-excursion
      (set-buffer " *GAMECOMPILE*")
      (goto-char (point-max))
      (insert "\n\n(setq PrimExpPat PEP)"))
    ;; process the game rules
    (when (and (not syntax-only) (search-forward cal-defrules-string nil t))
      (setq p (point))
      (backward-char 1)
      (condition-case condition
	  (forward-sexp)
	(error
	 (error "対応する閉括弧「]」がありません")))
      ;; parse the defrules by using PEP as PrimExpPat
      (ParseString (buffer-substring-no-properties p (1- (point))) 
		   'defrules (1- p)))
    (setq PEP PrimExpPat)
    (save-excursion
      (set-buffer " *GAMECOMPILE*")
      (goto-char (point-max))
      (insert "\n\n(setq PEP PrimExpPat)")
      (write-region (point-min) (point-max) (concat file "c")))
    ;; we return nil as the final value
    nil))

(defun parser-extend-prim-exp-pat (name)
  (setq PrimExpPat
	(concat (regexp-quote name) "\\|" PrimExpPat)))

;; the code below must be elaborated.
;;(defun parser-extend-prim-exp-pat (name)
  ;;(unless
      ;;(and (string-match PrimExpPat name)
	   ;;(= (match-end 0) (length name)))
    ;;(setq PrimExpPat
	  ;;(concat (regexp-quote name) "\\|" PrimExpPat))))

;; definitions and theorems

;; PrimExpList に (op "NAME") を追加する．NAME の長さに応じて適当な
;; 位置に挿入して追加する．

(defun cal-extend-prim-exp-list (name)
  (cal-insert-by-length name nil PrimExpList))

(defun cal-insert-by-length (name list1 list2)
  (if (null list2)
      ;; append item to list1
      (append list1 (list (list 'op name)))
    (if (<= (length name) (length (second (car list2))))
	(append list1 (list (list 'op name)) list2)
      (cal-insert-by-length 
       name 
       (append list1 (list (car list2)))
       (cdr list2)))))

(defun cal-get-def (name)
  (get (intern (concat cal-current-game ":" name)) 'cal-def))

(defun cal-get-thm (name)
  "Get theorem NAME in the cal-current-game."
  (if cal-current-game
      (cdr (assoc name (get (intern cal-current-game) 'thm-list)))
    nil))

(defun cal-check-def (game name defbody)
  (if (string= game cal-current-game)
      (if (nf-eq (cal-get-def name) defbody)
	  t
	;; reset def silently
	(cal-remove-definition name t)
	nil)
    (error "プレイ中のゲームを %s にしてから解答してください" game)))

(defun cal-check-thm (game name thmbody)
  (if (string= game cal-current-game)
      (let ((thm (cal-get-thm name)))
	(if thm
	    ;; we compare theorem by discarding the derivaion in THM.
	    ;; we use EQUAL for the comparison of parameters, and
	    ;; we use NF-SEQ for the comparison of thm body.
	    ;; 
	    (if (and (equal (first thm) (first thmbody))
		     (nf-seq (second thm) (second thmbody)))
		t
	      ;; reset theorem silently
	      (cal-remove-theorem name t)
	      nil)
	  (error "「%s」という名前の定理はありません" name)))
    (error "プレイ中のゲームを %s にしてから解答してください" game)))

(defun cal-remove-from-list (item list)
  "remove ITEM from LIST."
  (let ((head nil) (cont t))
    (while (and cont list)
      (if (equal item (car list))
	  (setq list (cdr list)
		cont nil)
	(setq head (cons (car list) head)
	      list (cdr list))))
    (append (reverse head) list)))

(defun cal-remove-from-list2 (item list)
  "remove (ITEM...) from LIST."
  (let ((head nil) (cont t))
    (while (and cont list)
      (if (string= item (car (car list)))
	  (setq list (cdr list)
		cont nil)
	(setq head (cons (car list) head)
	      list (cdr list))))
    (append (reverse head) list)))

;;;; OLD VERSION ;;;;
;(defun cal-remove-from-list2 (item list)
;  "remove ITEM from LIST with modified equality check."
;  (let ((head nil) (cont t))
;    (while (and cont list)
;      (if (and
;	   (> (length (car (car list))) (length item))
;	   (string= (concat item "(")
;		    (substring (car (car list)) 0 (1+ (length item)))))
;	  (setq list (cdr list)
;		cont nil)
;	(setq head (cons (car list) head)
;	      list (cdr list))))
;    (append (reverse head) list)))

;; what commands do we have?

(defun cal-mk-regexp (list)
  "Construct a regular expression that matches each string in LIST,
where each string is a name of commands."
  (let ((result "") (cont t))
    (while cont
      (let ((item (car list)))
	(if (null (cdr list))
	    ;; the last item is treated differently
	    (setq result (concat result item)
		  cont nil)
	  (setq result (concat result item "\\|")
		list (cdr list))))) 
    (concat "\\(" result "\\)")))

(setq cal-command-0
      '(
	;;"help"
	"solved"
	"unsolved"
	"tokens"
	"syntax"
	"rules"
	"texit"
	"textt"
	"texrules"
	"bye"
	"list-definitions"
	"list-theorems"
	)
)

(setq cal-command-1
      '(
	"Q"
	"check"
	"demo"
	"play"
	"help"
	"myrecord"
	"news"
	"load"
	"ok"
	"comment"
	"print-token"
	"record"
	"reset"
	"texrule"
	"variable"
	"remove-definition"
	"remove-theorem"
	))

(setq cal-command-2
      '(
	"A"
	"defgame"
	"parse"
	"Definition"
	"Theorem"
	"check-syntax"
	"set"
	"rename-theorem"
	))

;; we should be able to replace below by explcit constants
;; when the system becomes more stable

(setq cal-command-exp-0 (cal-mk-regexp cal-command-0)
      cal-command-exp-1 (cal-mk-regexp cal-command-1)
      cal-command-exp-2 (cal-mk-regexp cal-command-2)
      cal-command-exp+ (cal-mk-regexp (append cal-command-1 cal-command-2))
      cal-command-exp 
      (cal-mk-regexp (append cal-command-0 cal-command-1 cal-command-2))
      )

(setq cal-completion-words
      '(
	;;("Answer")
	;;("Problem")
	("Definition")
	("LambdaTerm")
	("LambdaTermFrmn")
	("LambdaTermRed")
	("ArithTermFrmn")
	("ArithPropFrmn")
	("ArithProof")
	("PropFrmn")
	("PropProof")
	("PropProofRed")
	("Theorem")
	("bye")
	("check")
	("check-syntax")
	("command")
	("completion")
	("help")
	("history")
	("hyp-seq")
	("interval")
	("list-definitions")
	("list-theorems")
	("load")
	("news")
	("Abbrev")
	("Exp")
	("Push")
	("Subst")
	("ok")
	("comment")
	("parse")
	("print-token")
	("arith-proof-deriv")
	("proof-term-deriv")
	("record")
	("texrule")
	("myrecord")
	("red-deriv")
	("remove-definition")
	("remove-theorem")
	("rename-theorem")
	("reset")
	("set")
	("solved")
	("theorem")
	("unsolved")
	("variable")
	))

(setq cal-inbox-completion-words
      '(
	("Abbrev")
	("Exp")
	("LambdaTerm")
	("LambdaTermFrmn")
	("LambdaTermRed")
	("Nat")
	("Prop")
	("ArithTermFrmn")
	("ArithPropFrmn")
	("ArithProofTerm")
	("ArithProof")
	("PropFrmn")
	("PropProof")
	("PropProofRed")
	("Push")
	("Subst")
	("abort")
	("abort_frmn")
	("abs")
	("and")
	("apply_frmn")
	("axiom")
	;;("by")
	("and_elim_left")
	("and_elim_right")
	("and_frmn")
	("and_intro")
	("beta")
	("btm_elim")
	("btm_frmn")
	("case")
	("case_frmn")
	("const")
	("def_intro")
	("def_elim")
	("def_frmn")
	("denotes")
	("or_elim")
	("or_frmn")
	("or_intro_left")
	("or_intro_right")
	("eq")
	("eq_frmn")
	("exist_elim")
	("exist_frmn")
	("exist_intro")
	("imp")
	("imp_elim")
	("imp_frmn")
	("imp_intro")
	("in")
	("ind")
	("inl")
	("inr")
	("judgment")
	("keep")
	("lambda")
	("lambda_frmn")
	("left")
	("left_inj_frmn")
	("left_proj_frmn")
	("makes")
	("not")
	("or")
	("pair_frmn")
	("paren")
	("plus")
	("plus_frmn")
	("plus_0")
	("plus_s")
	;;("pull")
	("push")
	("push_const")
	("push_var1")
	("push_var2")
	("push_var3")
	("push_struct")
	("push_abs")
	("rec")
	("rec_0")
	("rec_s")
	("red")
	("repl")
	("repl_frmn")
	("right")
	("right_inj_frmn")
	("right_proj_frmn")
	("since")
	("split")
	("struct")
	("subst")
	("succ_frmn")
	("succ_elim")
	("theorem")
	("thru")
	("times")
	("times_frmn")
	("times_0")
	("times_s")
	;;("triv")
	("univ_elim")
	("univ_frmn")
	("univ_intro")
	("var1")
	("var2")
	("var3")
	("with")
	("zero_elim")
	("zero_frmn")
	))

(defun cal-command-args (command)
  (cond ((member command cal-command-1) 1)
	((member command cal-command-2) 2)
	(t (cal-report-error "cal-command-args: "))))

;; interface with checker

;;;;;;;;;;;;;;;;;;;;;;
;;                  ;;
;; check derivation ;;
;;                  ;;
;;;;;;;;;;;;;;;;;;;;;;

(defun cal-check-derivation (str)
  "Check if STR is a correct derivaion in CAL-CURRENT-GAME."
  (let ((result
	 (catch 'fail
	   (save-excursion
	     (nf-check-derivation
	      (ParseString str 'derivation))))))
    ;; for debug
    ;;(setq RESULT result)
    (if (parse-failed result)
	(error (parse-failed-str result))
      t)))

(defun cal-check-deriv (str game judg &optional context)
  "Check if STR is a correct derivaion in GAME of 
the judgment JUDG under CONTEXT."
  (let* ((re-pattern 
	  "[ \\|\t\\|\n]in[ \\|\t\\|\n]*\\([a-zA-Z][a-zA-Z0-9_]*\\)[ \\|\t\\|\n]*since[ \\|\t\\|\n]")
	 (gm
	  (let ((case-fold-search nil))
	    (if (string-match re-pattern str)
		(substring str (match-beginning 1) (match-end 1)))))
	 (beg (match-beginning 1))
	 (end (match-end 1))) 
    (if (null cal-current-game) (error "現在プレイ中のゲームはありません"))
    (unless (string= game cal-current-game)
      (error "play[%s] でプレイ中のゲームを %s にしてから解答してください" game game))
    (if gm 
	(if (string= gm cal-current-game)
	    ;; ok, fine
	    nil
	  ;; current game is not the GAME, so call CAL-PLAY
	  ;; non-interactively. 
	  (cal-set-epos beg end) 
	  (error "導出で指定したゲーム %s とプレイ中のゲーム %s が一致しません"
		 game cal-current-game))
      (error 
       "導出に必要なキーワード「in」と「since」が正しい位置にありません"))
    )
  ;; we first check the correctness of STR as a derivation, since
  ;; it will guarantee that it is certainly a derivation in the
  ;; correct game.
  (let* (tree
	 (result
	  (catch 'fail
	    (save-excursion
	      (nf-check-derivation
	       (setq tree (ParseString str 'derivation)))))))
    ;; for debug
    ;;(setq RESULT result)
    (if (parse-failed result)
	(error (parse-failed-str result))
      ;; now check the conclusion
      (if (nf-eq (ParseString judg 'judgment)
		 (exp-derivation-concl tree))
	  (if context
	      (if (nf-eq (ParseString context 'hyp-seq)
			 (exp-derivation-context tree))
		  t
		(error "問題で指定した仮定列と解答の仮定列が一致しません"))
	    t) 
	(error "問題で指定した判断と解答の結論の判断が一致しません")))))

(defun cal-check-deriv-meta (str game judg &optional context)
  "Check if STR is a correct derivaion in GAME of 
the judgment JUDG under CONTEXT.  JUDG may contain meta variables."
  (let* ((re-pattern 
	  "[ \\|\t\\|\n]in[ \\|\t\\|\n]*\\([a-zA-Z][a-zA-Z0-9_]*\\)[ \\|\t\\|\n]*since[ \\|\t\\|\n]")
	 (gm
	  (let ((case-fold-search nil))
	    (if (string-match re-pattern str)
		(substring str (match-beginning 1) (match-end 1)))))
	 (beg (match-beginning 1))
	 (end (match-end 1)))
    (if (null cal-current-game) (error "現在プレイ中のゲームはありません"))
    (unless (string= game cal-current-game)
      (error "play[%s] でプレイ中のゲームを %s にしてから解答してください" game game))
    (if gm 
	(if (string= gm cal-current-game)
	    ;; ok, fine
	    nil
	  ;; current game is not the GAME, so call CAL-PLAY
	  ;; non-interactively. 
	  (cal-set-epos beg end) 
	  (error "導出で指定したゲーム %s とプレイ中のゲーム %s が一致しません"
		 game cal-current-game))
      (error 
       "導出に必要なキーワード「in」と「since」が正しい位置にありません"))
    )
  ;; we first check the correctness of STR as a derivation, since
  ;; it will guarantee that it is certainly a derivation in the
  ;; correct game.
  (let* (tree
	 (result
	  (catch 'fail
	    (save-excursion
	      (nf-check-derivation
	       (setq tree (ParseString str 'derivation)))))))
    (if (parse-failed result)
	(error (parse-failed-str result))
      ;; now check the conclusion, which may be meta-judgment
      (if (nf-match-p 
	   ;; we must set CAL-META to T
	   (let ((cal-meta t)) (ParseString judg 'meta-judgment))
	   (exp-derivation-concl tree))
	  (if context
	      (if (nf-match-p
		   (let ((cal-meta t)) (ParseString context 'hyp-seq))
		   (exp-derivation-context tree))
		  t
		(error "問題で指定した仮定列と解答の仮定列が一致しません"))
	    t) 
	(error "問題で指定した判断と解答の結論の判断が一致しません")))))

(defun cal-string-closure (str beg-end)
  "Given a string STR and a region BEG-END=(BEG END) which specifies a
substring of STR, compute the smallest region with balanced
parentheses containing the given region.  The result is
given as a region."
  (let ((beg (first beg-end)) (end (second beg-end))
	(cont t) error-condition (dead-end (length str)))
    (while cont
      (setq error-condition nil)
      (condition-case condition
	  (ReadString (substring str beg end))
	(error
	 (setq error-condition condition)))
      (if error-condition
	  (let ((error-str (second error-condition)))
	    (cond ((string= error-str "Cannot find the matching open!")
		   ;; extend region to the left
		   (if (= beg 0)
		       ;; cannot extend to the left!
		       (error "Implementation error: cal-string-closure")
		     (setq beg (1- beg))))
		  ((string= error-str "Cannot find the matching close!")
		   ;; extend region to the right
		   (if (= end dead-end)
		       ;; cannot extend to the right!
		       (error "Implementation error: cal-string-closure")
		     (setq end (1+ end))))
		  ((string= error-str "Unbalanced parentheses")
		   ;; this case is same as above, since the error should
		   ;; have been caused by forward-sexp.
		   ;; extend region to the right
		   (if (= end dead-end)
		       ;; cannot extend to the right!
		       (error "Implementation error: cal-string-closure")
		     (setq end (1+ end))))
		  (t (error "Implementation error: cal-string-closure"))))
	(setq cont nil)))
    (list beg end)))

(defun cal-exp-region (e)
  "Compute the minimum and maximum pos info in E and
return the result as a list, or nil, if no info."
  (cond ((and (exp-var-p e) (= (length e) 2) (integerp (second e)))
	 ;; this means that e == (var int) and should return nil
	 nil)
	((or (exp-varref-p e) (exp-op-p e))
	 (let ((pos (car (last e))))
	   (if (integerp pos) 
	       ;; we decrement POS by 1, since it will be used
	       ;; as an argument of substring whose index begins
	       ;; with 0, while the value of POS begins with 1
	       ;; we also have to compute the length of the token
	       ;; to get the correct value of max
	       ;; e.g., (ParseString "##x" 'varref) = (varref "#" "#" "x" 3)
	       ;; and (ParseString "nil" 'op) = (op "nil" 1)
	       (let ((length
		      (if (exp-sharp-var-p e)
			  (length (cadr (reverse e)))
			(length (second e)))))
		 (list (1- pos) (+ (1- pos) length) ))
	     nil)))
	((exp-null e) nil)
	((exp-sexp-p e) nil)
	((exp-unit-p e) (cal-unit-core-region (second e)))
	((exp-Abs-p e) (cal-exp-region (fourth e)))
	((or (exp-svar-p e) 
	     (exp-sapp-p e)
	     (exp-qq-p e)) 
	 nil)
	(t
	 ;; in this case, E is an NF pair
	 (let ((l-region (cal-exp-region (car e)))
	       (r-region (cal-exp-region (cdr e))))
	   (if (null l-region)
	       r-region
	     (if (null r-region)
		 l-region
	       (let ((l-min (first l-region)) (l-max (second l-region))
		     (r-min (first r-region)) (r-max (second r-region)))
		 (list (min l-min r-min) (max l-max r-max)))))))))

(defun cal-unit-core-region (c)
  (let ((key (car c)))
    (cond ((memq key '(var op))
	   (let ((pos (car (last c))))
	     (if (integerp pos) 
		 (list (1- pos) (+ (1- pos) (length (second c))))
	       nil)))
	  ((eq key 'sexp) nil)
	  (t ; key = paren
	   (let ((unit-core-list (cddr c)) min max)
	     (while unit-core-list
	       (let* ((unit-core (car unit-core-list))
		      (region (cal-unit-core-region unit-core)))
		 (when region
		   (if min
		       (setq min (min min (first region))
			     max (max max (second region)))
		     (setq min (first region)
			   max (second region))))
		 (setq unit-core-list (cdr unit-core-list))))
	     (if min (list min max) nil))))))

(defun cal-toklist-region (list)
  "Compute the minimum and maximum pos info in the token list
LIST and return the result as a list (min max), or nil, if no info."
  (let ((min nil) (max nil))
    (while list
      (let* ((token (car list)) (key (car token)))
	(cond ((memq key '(var op svar))
	       (let ((pos (car (last token))))
		 (when (integerp pos)
		   (if min
		       (setq min (min min (1- pos))
			     max (max max (+ (1- pos) (length (second token))))
			     )
		     (setq min (1- pos) 
			   max (+ (1- pos) (length (second token))))))))
	      ((eq key 'sexp) nil)
	      ((eq key 'unit) 
	       (let* ((min-max (cal-unit-core-region (second token)))
		      ;; MIN-MAX may be NIL, but that is fine
		      (min-candidate (first min-max))
		      (max-candidate (second min-max)))
		 (when min-candidate
		   (if min
		       (setq min (min min min-candidate)
			     max (max max max-candidate))
		     (setq min min-candidate
			   max max-candidate)))))
	       ((eq key 'paren)
		(let* ((min-max (cal-toklist-region (cddr token)))
		       ;; MIN-MAX may be NIL, but that is fine
		       (min-candidate (first min-max))
		       (max-candidate (second min-max)))
		  (when min-candidate
		    (if min
			(setq min (min min min-candidate)
			      max (max max max-candidate))
		      (setq min min-candidate
			    max max-candidate)))))
	       (t (cal-report-error "cal-toklist-region"))))
      (setq list (cdr list)))
    (if min (list min max) nil)))

(defun cal-varref-region (var)
  "Compute the minimum and maximum pos info for VAR which is an
ordinary variable or a sharp-var. The result is NIL if no info is
stored in VAR."
  (let ((pos (car (last var))))
    (if (integerp pos) 
	;; we decrement POS by 1, since it will be used
	;; as an argument of substring whose index begins
	;; with 0, while the value of POS begins with 1
	;; we also have to compute the length of the token
	;; to get the correct value of max
	;; e.g., (ParseString "##x" 'varref) = (varref "#" "#" "x" 3)
	;; and (ParseString "nil" 'op) = (op "nil" 1)
	(let ((length
	       (if (exp-sharp-var-p var)
		   (length (cadr (reverse var)))
		 (length (second var)))))
	  (list (1- pos) (+ (1- pos) length)))
      nil)))


;; parser related functions

;; history

(defun cal-history-up ()
  (interactive)
  (if (< (point) (cal-prompt-point))
      (error ""))
  (if (= cal-history-count cal-prompt-count)
      ;; input line should be empty
      (progn
	(cal-skip)
	(or (= (point) (1+ (cal-prompt-point)))
	    (error ""))))
  (if (= cal-history-count 1)
      (error "これ以上上にはいけません!"))
  (setq cal-history-count (1- cal-history-count))
  (delete-region (1+ (cal-prompt-point)) (point))
  (insert (cal-previous-input)))

(defun cal-history-down ()
  (interactive)
  (if (< (point) (cal-prompt-point))
      (error ""))
  (if (= cal-history-count cal-prompt-count)
      (error "これ以上下にはいけません!"))
  (setq cal-history-count (1+ cal-history-count))
  (delete-region (1+ (cal-prompt-point)) (point))
  (if (< cal-history-count cal-prompt-count)
      (insert (cal-previous-input))))

(defun cal-previous-input ()
  "input command issued when prompt count was cal-history-count"
  (let (beg)
    (save-excursion
      (if (re-search-backward 
	   (format cal-prompt-pattern cal-history-count) nil t)
	  (progn
	    (goto-char (match-end 0))
	    (skip-chars-forward " \t\n")
	    (setq beg (point))
	    (if (re-search-forward
		 (format cal-prompt-pattern (1+ cal-history-count)) nil t)
		;; ok, we should be able to find the region
		(progn
		  (goto-char beg)
		  (cond ((cal-looking-at cal-command-exp-0)
			 ;; check if it is actually 0-ary
			 (goto-char (match-end 0))
			 (skip-chars-forward " \t")
			 (if (eolp)
			     ;; yes, it is 0-ary
			     (buffer-substring beg (match-end 0))
			   ;; no, it is unary since we must be
			   ;; looking at ?\[
			   (forward-sexp)
			   (buffer-substring beg (point))))
			((cal-looking-at cal-command-exp-1)
			 (if (search-forward "\[" nil t)
			     (progn
			       ;; backup one charcter, before jump
			       (goto-char (1- (point)))
			       (forward-sexp)
			       (buffer-substring beg (point))
			       )
			   (error "CAL <%s> のコマンド行が不完全です!" 
				  cal-history-count)))
			 ((cal-looking-at cal-command-exp-2)
			  (if (search-forward "\[" nil t)
			      (progn
				(goto-char (1- (point)))
				(forward-sexp)
				(if (search-forward "\[" nil t)
				    (progn
				      ;; back up one chracter
				      (backward-char 1)
				      (forward-sexp)
				      (buffer-substring beg (point)))
				  (error "CAL <%s> のコマンド行が不完全です!"
					 cal-history-count)))
			    (error "CAL <%s> のコマンド行が不完全です!"
				   cal-history-count)))
			 (t (error "CAL <%s> のコマンド行が不完全です!"
				   cal-history-count))))
	      (error "CAL <%s> のコマンド行が不完全です" cal-history-count)))
	(error "CAL <%s> のコマンド行が不完全です" cal-history-count)))))

(defun cal-toggle-input ()
  (interactive)
  (if (< (point) (cal-prompt-point))
      (backward-char)
    (goto-char (cal-prompt-point))
    (if (or (eolp) (not (= (following-char) ? )))
	(insert " "))
    (forward-char 1)
    (if (eobp)
	(insert cal-partial-input)
      (setq cal-partial-input
	    (buffer-substring (point) (point-max)))
      (delete-region (point) (point-max)))))

;; completion

(setq cal-word-chars "-_a-zA-Z")

(defun cal-completion ()
  "completes partial word. use different lists for completion
depending on whethe point is in box or not"
  (interactive)
  (let ((p (point))
	(in-box (cal-in-box))
	str1 str2)
    (skip-chars-backward cal-word-chars)
    (setq str1 (buffer-substring (point) p))
    (if (string= str1 "")
	(insert "\t")
      (if (setq str2
		(try-completion
		 str1
		 (if (and in-box
			  (or 
			   (string= cal-current-command "Exp")
			   (string= cal-current-command "Push")
			   (string= cal-current-command "Subst")
			   (string= cal-current-command "Abbrev")
			   (string= cal-current-command "ArithTermFrmn")
			   (string= cal-current-command "ArithPropFrmn")
			   (string= cal-current-command "ArithProof")
			   (string= cal-current-command "PropFrmn")
			   (string= cal-current-command "PropProof")
			   (string= cal-current-command "PropProofRed")
			   (string= cal-current-command "LambdaTerm")
			   (string= cal-current-command "LambdaTermFrmn")
			   (string= cal-current-command "LambdaTermRed")
			   (string= cal-current-command "arith-proof-deriv")
			   (string= cal-current-command "proof-term-deriv")
			   (string= cal-current-command "check-syntax")
			   (string= cal-current-command "parse")
			   (string= cal-current-command "rename-theorem")
			   (string= cal-current-command "remove-theorem")
			   (and (string= cal-current-command
					 "A")
				(= (second in-box) 2))
			   (and (string= cal-current-command
					 "Definition")
				(= (second in-box) 2))
			   (and (string= cal-current-command
					 "Theorem")
				(= (second in-box) 2))
			   ))
		     cal-inbox-completion-words
		   cal-completion-words)))
	  (if (equal str2 t)
	      (progn
		(message "完全な単語なのでこれ以上補完できません.")
		(goto-char p))
	    (delete-region (point) p)
	    (insert str2))
	(goto-char p)
	(error "「%s」は補完できません!" str1)))))

(defun cal-in-hyp ()
  "check if point is in a hyp-seq of a derivation."
  (let ((p (cal-prompt-point))
	(q (point))
	l)
    (save-excursion
      (if (setq l (cal-find-open-paren))
	  (if (= ?\{ (car l))
	      ;; point is in a brace, so check if point is
	      ;; after a ├ sign
	      (if (search-backward "├" (second l) t)
		  ;; we found a turnstile before open brace,
		  ;; in this case we check if we can find a semicolon
		  ;; before the turnstile
		  (progn
		    (goto-char q)
		    (if (search-backward ";" (match-end 0) t)
			;; this means point is in hypothesis
			t
		      nil))
		t))
	;; in this case, point is at the top level
	(if (search-backward "├" p t)
	    nil
	  t)))))

(defun cal-in-lambda ()
  "check if point is just after a lambda."
  (save-excursion
    (skip-chars-backward " \t\n")
    (backward-char 1)
    (looking-at "λ")))

(defun cal-undo ()
  "if in box, support simple undo"
  (interactive)
  (let ((in-box (cal-in-box)))
    (if in-box
	(let ((p (1+ (car in-box))))
	  (if (= (point) p)
	      (insert cal-old-arg)
	    (setq cal-old-arg (buffer-substring p (point)))
	    (delete-region p (point))))
      (error ""))))

;; pretty reader

(defun cal-prompt-point ()
  "returns the beg point of the current command."
  (let ((error-occurred nil))
    (save-excursion
      (goto-char (point-max))
      (if (search-backward (concat "\n" (cal-current-prompt)) nil t)
	  (match-end 0)
	(goto-char (point-max))
	(insert "\n" (cal-current-prompt) " ")
	(goto-char (point-max)) ))))

(defun cal-in-comment (&optional point)
  "check if (point) is in comment."
  (let (p q)
    (save-excursion
      (if point (goto-char point))
      (setq p (point))
      (end-of-line)
      (setq q (point))
      (beginning-of-line)
      (if (search-forward ";;" q t)
	  ;; this line contains a comment, so check if p is
	  ;; really in comment.
	  (<= (match-beginning 0) p)
	;; this line does not contain a comment
	nil))))

(defun cal-search-backward (string &optional bound no-error)
  "search backeard ignoring comments."
  (let (v)
    (if (and bound (< (point) bound))
	(error "カーソルがプロンプトより前にあるとコマンドは実行できません!"))
    (if (setq v (search-backward string bound no-error))
	(if (cal-in-comment (point))
	    ;; current point is in comment, so call cal-search-backward
	    ;; recursively
	    (cal-search-backward string bound no-error)
	  ;; found the target! so return v.
	  v)
      nil)))

(defun cal-in-box ()
  "check if (point) is within a [] box.  if in box, returns a list
 (pos 1/2) where pos is the position of the opening \[ , and the second
component of the list is 1 if the box is the first box and 2 if second."
  (interactive)
  ;; first set cal-current-command properly
  (save-excursion
    (goto-char (cal-prompt-point))
    (if (or (eolp) (not (= (following-char) ? )))
	(insert " ") (forward-char 1))
    (cal-skip)
    (if (cal-looking-at cal-command-exp)
	(setq cal-current-command (buffer-substring (point) (match-end 0)))
      (setq cal-current-command nil)))
  (let ((p (point))
	(prompt-point (cal-prompt-point))
	pos
	(open nil))
    (save-excursion
      (goto-char prompt-point)
      (if (search-forward "\[" p t)
	  ;; found the first open bracket
	  (progn
	    (forward-char -1)
	    (setq open (point))
	    (if (cal-forward-sexp 1)
		(if (< p (point))
		    (if (= p (1- (point)))
			;; P is on the closing bracket
			nil
		      ;; P is in the first box
		      (list open 1))
		  ;; P is past the first argmument, so we look for
		  ;; the second bracket.
		  (if (search-forward "\[" p t)
		      ;; found the second open bracket
		      (progn
			(forward-char -1)
			(setq open (point))
			(if (cal-forward-sexp 1)
			    (if (< p (point))
				(if (= p (1- (point)))
				    ;; P is on the closing bracket
				    nil
				  ;; P is in the second box
				  (list open 2))
			      ;; P is past the second argmuent
			      nil)
			  ;; P is in the second box
			  (list open 2)))
		    ;; couldn't find the second open bracket
		    nil))
	      ;; P is in the first bracket
	      (list open 1)))
	;; couldn't find the first open bracket
	nil))))

(defun cal-forward-sexp (count)
  "simply call forward-sexp, but returns t if successful and
nil if error occured."
  (let ((p (point)))
    (condition-case conditions
	(forward-sexp count)
      (error
       (goto-char p)))
    (> (point) p)
    ))

(defun cal-arg-region (&optional net-str)
  "compute the net region of the argument surrounded by \[ and \].
when this function is called, current point must be looking at \[.
point will be moved just after the closing bracket.  If optional
NET-STR is given, the string determined by the region is returned
instead."
  (let ((p (1+ (point))) q r)
    (forward-sexp 1)
    (backward-char 1)
    (if (looking-at "\]")
	(progn
	  (setq r (1+ (point)))
	  (cal-skip-back)
	  (if (= (point) p)
	      (progn
		;; in this case net arg is empty
		(goto-char r)
		(if net-str "" (list p p)))
	    ;; point is the end of the net region
	    (setq q (point))
	    (goto-char p)
	    (cal-skip)
	    (setq p (point))
	    (goto-char r)
	    (if net-str
		(save-excursion
		  ;; if p is not bolp, then we might better to
		  ;; back up to bol
		  (goto-char p)
		  (beginning-of-line)
		  (cal-skip)
		  (if (= p (point))
		      (progn
			(beginning-of-line))
		    (goto-char p))
		  (buffer-substring-no-properties (point) q))
	      (list p q))
	    ))
      (error "括弧の対応がとれていません!"))))

(defun cal-return ()
  (interactive)
  (let* ((prompt (cal-current-prompt))
	 (point (point));; current point
	 prompt-point
	 (len (length prompt))
	 box-pos
	 p q
	 j-str
	 error-str
	 ;; EPOS = (BEG END), region of an error.
	 ;; this variable will be dynamiaclly bound by other
	 ;; functions
	 EPOS EPOS2
	 command arg1 arg2)
    (setq prompt-point (cal-prompt-point))
    (if (< (point) prompt-point)
	(progn
	  (goto-char (1+ prompt-point))
	  (error "プロンプトの前に挿入できません")))
    (if (setq box-pos (cal-in-box))
	(progn
	  ;; insert "\n" and supply an appropriate indentation.
	  (cal-clear-white)
	  ;; check if the line ends with "since"
	  (save-excursion
	    (setq p (point))
	    (forward-word -1)
	    (if (string= "since" (buffer-substring (point) p))
		(progn
		  (goto-char (car box-pos))
		  (if (search-forward "├" p t)
		      (progn
			(skip-chars-forward " \t\n")
			(setq q (point))
			(goto-char p)
			(if (re-search-backward "in[ \t\n]" q t)
			    (progn
			      (goto-char (match-beginning 0))
			      (skip-chars-backward " \t\n")
			      (setq j-str (buffer-substring q (point))))
			  (error "必要なキーワード「in」がありません")))
		    (error "必要な記号「├」がありません"))))
	    )
	  (insert "\n")
	  (if j-str
	      ;; insert J-STR at the beginning of the line
	      (progn
		(insert j-str " by "))
	    (insert-char ?\  (cal-indent))))
      ;; not-in-box means point should be after the prompt line.
      (goto-char prompt-point)
      (if (eolp) (insert " ") (forward-char 1))
      (cal-skip)
      (if (cal-looking-at cal-command-exp)
	  (progn
	    (setq command (buffer-substring (point) (match-end 0)))
	    (goto-char (match-end 0))
	    (cal-skip)
	    (if (eolp)
		(if (member command cal-command-0)
		    ;; we have a nullary command here, so submit
		    ;; the commad
		    (cal-process-command command)
		;; other commands require at least one arg, so
		;; supply an opening bracket.
		(cal-insert-string "\["))
	      ;; otherwise we expect to have an opening bracket here.
	      (if (= (following-char) ?\[)
		  ;; since we are not in the box, we should be able to
		  ;; find the closing bracket.
		  (progn
		    (setq arg1 (cal-arg-region))
		    ;; now we check the number of arguments the
		    ;; command expects.
		    (if (= (cal-command-args command) 1)
			;; now that we have a one-arg command and
			;; its arg, we just submit it
			;; we use condition-case to be able to
			;; goto error position in *cal* buffer
			(condition-case condition
			    (cal-process-command command arg1)
			  (error
			   ;; first we erase the closing bracket
			   (goto-char (point-max))
			   (search-backward "\]" nil t)
			   ;; double check!
			   (if (looking-at "\]") (delete-char 1))
			   (when EPOS
			     (let ((beg (+ (first arg1) (first EPOS)))
				   (end (+ (first arg1) (second EPOS))))
			       (goto-char beg)
			       (cal-put-on-overlay beg end)
			       (when EPOS2
				 (let ((beg (+ (first arg1) (first EPOS2)))
				       (end (+ (first arg1) (second EPOS2))))
				   (cal-put-on-overlay2 beg end)))
			       (setq EPOS nil EPOS2 nil)))
			   (if (and cal-demo-on
				    (eq 'error (car condition)))
			       (let ((error-str
				      (eval (cons 'format (cdr condition)))))
				 ;; remove hook temprarily
				 (remove-hook 'after-change-functions
					      'cal-after-change-function t)
				 (message error-str)
				 (ding)
				 (goto-char (point-max))
				 (cal-insert-string "\]")
				 (cal-insert error-str)
				 (cal-clear-white)
				 (cal-increment-prompt-count)
				 ;; add hook again
				 (add-hook 'after-change-functions 
					   'cal-after-change-function nil t)
				 )
			     (eval condition))))
		      ;; we have a two-args command here.
		      ;; so, see if the second arg is also in the line.
		      ;; repeat the same as above.
		      ;; but, before that, check the first arg is ok
		      (cal-check-first-arg command arg1)
		      (cal-skip)
		      (if (= (following-char) ?\[)
			  (progn
			    (setq arg2 (cal-arg-region))
			    ;; we know that we have two args here
			    ;; so submit it
			    (condition-case condition
				(cal-process-command command arg1 arg2)
			      (error
			       ;; first we erase the closing bracket
			       (goto-char (point-max))
			       (search-backward "\]" nil t)
			       ;; double check!
			       (if (looking-at "\]") (delete-char 1))
			       (when EPOS
				 (let ((beg (+ (first arg2) (first EPOS)))
				       (end (+ (first arg2) (second EPOS))))
				   (goto-char beg)
				   (cal-put-on-overlay beg end)
				   (when EPOS2
				     (let ((beg (+ (first arg2) (first EPOS2)))
					   (end 
					    (+ (first arg2) (second EPOS2))))
				       (cal-put-on-overlay2 beg end)))
				   (setq EPOS nil EPOS2 nil)))
			       (if (and cal-demo-on
					(eq 'error (car condition)))
				   (let ((error-str
					  (eval 
					   (cons 'format (cdr condition)))))
				     ;; remove hook temprarily
				     (remove-hook 'after-change-functions
						  'cal-after-change-function t)
				     (message error-str)
				     (ding)
				     (goto-char (point-max))
				     (cal-insert-string "\]")
				     (cal-insert error-str)
				     (cal-clear-white)
				     (cal-increment-prompt-count)
				     ;; add hook again
				     (add-hook 'after-change-functions 
					       'cal-after-change-function 
					       nil t)
				     )
				 (eval condition))) ))
			(if t ;; (eolp)
			    (cal-insert-string "\[")
			  (error
			   "ここには「[」がないといけません!")))))
		(error "ここには「[」がないといけません!"))))
	(if (eolp)
	    (setq error-str "")
	  (setq p (point))
	  (skip-chars-forward cal-word-chars)
	  (if (= p (point))
	      (error "文字「%s」はコマンド名には使えません!"
		     (buffer-substring
		      (point)
		      (save-excursion (forward-char 1) (point))))
	    (setq error-str (buffer-substring p (point)))))
	(goto-char point)
	(if (= point prompt-point)
	    (if (eolp) (insert " ") (forward-char 1)))
	(if (string= error-str "")
	    (if cal-demo-on
		;; in this case, try to continue the demo session
		(let ((str (cal-get-a-command)))
		  (if str 
		      (progn
			(setq cal-demo-command t)
			(insert str))
		    ;; terminate the demo session 
		    (cal-demo "")
		    (save-excursion
		      (set-buffer " *CALDEMO*")
		      (erase-buffer))
		    (cal-clear-white) 
		    (cal-increment-prompt-count)))
	      (error "コマンドがありません"))
	  (error "「%s」はコマンドではありません" error-str))))))

(defun cal-space ()
  "Insert CAL-CURRENT-GAME when space is typed just after \"in\",
otherwise just insert a space."
  (interactive)
  (insert " ")
  (let* ((inbox (cal-in-box))
	 (p (car inbox))
	 (case-fold-search t))
    (when
	(save-excursion
	  (backward-char 1)
	  (and cal-current-game
	       inbox
	       (save-excursion (re-search-backward "[ \n\t]in" p t))
	       (= (point) (match-end 0))
	       (not (re-search-forward "[ \n\t]in[ \n\t]" (point-max) t))
	       (not (re-search-forward "[ \n\t]since[ \n\t]" (point-max) t))
	       (save-excursion
		 (goto-char (1+ (match-beginning 0)))
		 (and (not (re-search-backward "[ \n\t]in[ \n\t]" p t))
		      (search-backward "├" p t)))))
	;; point is just after the first "in" in in-box, and it is after
	;; a "├" in in-box
	  (insert cal-current-game " since")
	  (cal-return))))

(defun cal-set-epos (&optional beg end)
  "Set error position.  This function is called from within
CAL-CHECK-DERIV.  If optional BEG and END are given, they are
used."
  (if beg
      (setq EPOS (list beg end))
    (setq EPOS (list (1- rule-pos) (+ (1- rule-pos) (length rule-name))))))

(defun cal-set-epos2 (beg end)
  "Set error position.  This function is called from within
CAL-CHECK-DERIV."
  (setq EPOS2 (list beg end)))

(defun cal-put-on-overlay (beg end)
  "Put an overlay on error position."
  (setq cal-overlay (make-overlay beg end))
  (overlay-put cal-overlay 'face 'cal-error-face))

(defun cal-put-on-overlay2 (beg end)
  "Put an overlay on error position."
  (setq cal-overlay2 (make-overlay beg end))
  (overlay-put cal-overlay2 'face 'cal-error2-face))

(defun cal-put-off-overlay ()
  "Put off an overlay at error position."
  (when cal-overlay 
    (overlay-put cal-overlay 'face nil))
  (when cal-overlay2
    (overlay-put cal-overlay2 'face nil))
  ;;(setq cal-overlay nil cal-overlay2 nil)
  )

(defun cal-after-change-function (beg end len)
  (when cal-overlay
    (cal-put-off-overlay)))

(defun cal-clear-white ()
  "delete white chars after point and at the end of the current line,
and if the lines below point are all white then delete them as well."
  (let ((p (point)) q)
    (skip-chars-forward " \t")
    (delete-region p (point))
    (end-of-line)
    (setq q (point))
    (skip-chars-backward " \t")
    (delete-region q (point))
    (if (cal-all-the-rest-are-white)
	;; wipe them out
	(delete-region (point) (point-max)))
    (goto-char p)))

(defun cal-all-the-rest-are-white ()
  (save-excursion
    (skip-chars-forward " \t\n")
    (eobp)))

(defun cal-find-open-paren ()
  "this function should be called only when point is inside a box.
returns a list of the paren found and its position. point is unchanged."
  (let ((cont t) c l (p (point)))
    ;; insert a fake closing paren
    (insert "\)")
    (backward-sexp 1)
    (setq c (following-char))
    (setq l
	  (cond ((= c ?\[) (if (cal-in-box) (list c (point)) nil))
		((= c ?\() (list c (point)))
		((= c ?\<) (list c (point)))
		((= c ?\{) (list c (point)))
		(t (cal-report-error "cal-find-open-paren"))))
    (goto-char p)
    (delete-char 1)
    l
    ))

(defun cal-indent ()
  (let ((l (cal-find-open-paren)))
    (if l
	(let ((c (car l))
	      (pos (second l))
	      m
	      p q)
	  (save-excursion
	    ;; jumpt to the opening paren
	    (goto-char pos)
	    (if (or (= c ?\() (= c ?<))
		(1+ (current-column))
	      ;; c = ?\{ or ?\[
	      ;; check if there is another open paren on the line
	      (beginning-of-line)
	      (setq p (point))
	      (goto-char pos)
	      (setq m (cal-find-open-paren))
	      (if m
		  (progn
		    (setq q (second m))
		    (if (<= p q)
			;; we have another open paren on the line.
			;; so jump to that paren
			(progn
			  (goto-char q)
			  (forward-char 1)
			  (skip-chars-forward " \t")
			  (+ (current-column) cal-indent-unit))
		      ;; we don't have extra open paren, so compute the
		      ;; column of the first non-white char on the line.
		      (beginning-of-line)
		      (skip-chars-forward " \t")
		      (+ (current-column) cal-indent-unit)))
		      (beginning-of-line)
		      (skip-chars-forward " \t")
		(+ (current-column) cal-indent-unit)))))
    0)))

(defun cal-get-problem-no ()
  ;; returns the problem number string, if the previous command issued
  ;; was "Problem", returns nil otherwise
  (interactive)
  (save-excursion
    (set-buffer (get-buffer-create " *CALLOG*"))
    (goto-char (point-max))
    (search-backward "\n-----" nil t)
    (beginning-of-line)
    (if (looking-at "Q\\[")
	(let ((p (match-end 0)))
	  (search-forward "]" nil t)
	  (int-to-string (string-to-int (buffer-substring p (1- (point))))))
      nil)))

(defun cal-open-bracket ()
  (interactive)
  (if (cal-in-box)
      (insert "[")
    ;; check if the current command is ok
    (save-excursion
      (goto-char (cal-prompt-point))
      (if (or (eolp) (not (= (following-char) ? )))
	  (insert " ") (forward-char 1))
      (cal-skip)
      (if (cal-looking-at cal-command-exp)
	  (setq cal-current-command (buffer-substring (point) (match-end 0)))
	(setq cal-current-command nil)))
    (if cal-current-command
	(if (member cal-current-command cal-command-0)
	    ;; execute the command
	    (cal-return) 
	  (let (prob-no)
	    (cal-insert-string "\[")
	    ;; insert problem no if the previous command issued was the
	    ;; "Problem" and the current command is "Answer".
	    (if (and 
		 (string= cal-current-command "A")
		 (setq prob-no (cal-get-problem-no))
		 (= (second (cal-in-box)) 1))
		(insert prob-no "\]\["))))
      (error "正しいコマンドがありません!"))))

(defun cal-close-bracket ()
  (interactive)
  (if (cal-in-box)
      (let ((p (point))
	    (indent (cal-indent)))
	(insert "\]")
	(backward-sexp 1)
	(unless (= (following-char) ?\[)
	  (goto-char p)
	  (delete-char 1)
	  (error "対応する「[」がないので「]」を挿入できません!"))
	(goto-char p)
	(beginning-of-line)
	(skip-chars-forward " \t")
	(if (= p (point))
	    ;; adjust indentation
	    (progn
	      (delete-char 1)
	      (move-to-column (max 0 (- indent cal-indent-unit)) t)
	      (insert "\]"))
	  (goto-char (1+ p)))
	(if (cal-in-box) (blink-matching-open))
	(unless (cal-in-box) 
	  ;; reset CAL-OLD-ARG
	  (setq cal-old-arg "")
	  (add-text-properties (1- (point)) (point)
			       '(face cal-insert-face))
	  (cal-return)))
    (error "「]」は [] の外では使えません!")))

(defun cal-open-brace ()
  (interactive)
  (if (cal-in-box)
      (insert "\{")
    (error "「{」は [] の外では使えません!")))

(defun cal-close-brace ()
  (interactive)
  (if (cal-in-box)
      (let ((p (point))
	    (indent (cal-indent)))
	(insert "\}")
	(backward-sexp 1)
	(if (/= (following-char) ?\{)
	    (progn
	      (goto-char p)
	      (delete-char 1)
	      (error "対応する「{」がないので「}」を挿入できません!"))
	  (goto-char p)
	  (beginning-of-line)
	  (skip-chars-forward " \t")
	  (if (= p (point))
	      ;; adjust indentation
	      (progn
		(delete-char 1)
		(move-to-column (- indent cal-indent-unit) t)
		(insert "\}")
		(blink-matching-open)
		)
	    (goto-char (1+ p))
	    (blink-matching-open)
	    )))
    (error "「}」は [] の外では使えません!")))

(defun cal-open-paren ()
  (interactive)
  (if (cal-in-box)
      (insert "\(")
    (error "「(」は [] の外では使えません!")))

(defun cal-close-paren ()
  (interactive)
  (if (cal-in-box)
      (let ((p (point))
	    (indent (cal-indent)))
	(insert "\)")
	(backward-sexp 1)
	(if (/= (following-char) ?\()
	    (progn
	      (goto-char p)
	      (delete-char 1)
	      (error "対応する「(」がないので「)」を挿入できません!"))
	  (goto-char p)
	  (beginning-of-line)
	  (skip-chars-forward " \t")
	  (if (= p (point))
	      ;; adjust indentation
	      (progn
		(delete-char 1)
		(move-to-column (- indent 1) t)
		(insert "\)")
		(blink-matching-open)
		)
	    (goto-char (1+ p))
	    (blink-matching-open)
	    )))
    (error "「)」は [] の外では使えません!")))

(defun cal-open-angle ()
  (interactive)
  (if (cal-in-box)
      (insert "\<")
    (error "「<」は [] の外では使えません!")))

(defun cal-close-angle ()
  (interactive)
  (if (cal-in-box)
      (let ((p (point))
	    (indent (cal-indent)))
	(insert "\>")
	(backward-sexp 1)
	(if (/= (following-char) ?\<)
	    (progn
	      (goto-char p)
	      (delete-char 1)
	      (error "対応する「<」がないので「>」を挿入できません!"))
	  (goto-char p)
	  (beginning-of-line)
	  (skip-chars-forward " \t")
	  (if (= p (point))
	      ;; adjust indentation
	      (progn
		(delete-char 1)
		(move-to-column (- indent 1) t)
		(insert "\>")
		(blink-matching-open)
		)
	    (goto-char (1+ p))
	    (blink-matching-open)
	    )))
    (error "「>」は [] の外では使えません!")))

;; command interpreter

(defun cal-defeq-symbol (arg)
  (interactive "P")
  (insert "≡"))

(defun cal-in (arg)
  (interactive "P")
  (insert "∈"))

(defun cal-imp (arg)
  (interactive "P")
  (insert "⊃"))

(defun cal-and (arg)
  (interactive "P")
  (insert "∧"))

(defun cal-or (arg)
  (interactive "P")
  (insert "∨"))

(defun cal-All (arg)
  (interactive "P")
  (insert "∀")
  (if cal-expand-long
      (progn
	(insert "()[")
	(backward-char 2))))

(defun cal-Exists (arg)
  (interactive "P")
  (insert "∃")
  (if cal-expand-long
      (progn
	(insert "()[")
	(backward-char 2))))

(defun cal-false (arg)
  (interactive "P")
  (insert "⊥"))

(defun cal-not (arg)
  (interactive "P")
  (insert "¬"))

(defun cal-proves (arg)
  (interactive "P")
  (insert "├"))

(defun cal-univ (arg)
  (interactive "P")
  (insert "Π"))

(defun cal-yields (arg)
  (interactive "P")
  (insert "⇒"))

(defun cal-Yields (arg)
  (interactive "P")
  (insert "→"))

(defun cal-open-qq (arg)
  (interactive "P")
  (insert "《"))

(defun cal-close-qq (arg)
  (interactive "P")
  (insert "》"))

(defun cal-lambda (arg)
  (interactive "P")
  (insert "λ")
  (if cal-expand-long
      (progn
	(insert "()[")
	(backward-char 2))))

(defun cal-slash (arg)
  (interactive "P")
  (insert "/"))

(defun cal-blank (arg)
  (interactive "P")
  (insert "□"))

(defun cal-key-help (arg)
  (interactive "P")
  (message 
   "p:├, i:⊃, a:∧, o:∨, n:¬, f:⊥, d:≡, e:∈, l:λ, A:∀, E:∃, <:《, >:》, y:⇒, Y:→, u:Π"))

(defun cal-submit ()
  "Submit the nearest expression around point."
  (interactive)
  (goto-char (cal-prompt-point))
  (cal-skip)
  ;;(end-of-line)
  (if (cal-looking-at cal-command-exp)
      (let* ((beg (match-beginning 0))
	     (end (match-end 0))
	     (command (buffer-substring beg end))
	     str1 str2
	    p q r)
	(if (member command cal-command-1)
	    (progn
	      (goto-char end)
	      (skip-chars-forward " \t\n")
	      (if (= (following-char) ?\[)
		  (progn
		    (setq p (1+ (point)))
		    (forward-sexp 1)
		    (setq r (point))
		    (backward-char 1)
		    (if (= (following-char) ?\])
			(progn
			  (setq q (point))
			  (goto-char p)
			  (cal-skip)
			  (setq p (point))
			  (goto-char q)
			  (cal-skip-back)
			  (setq str1 (list p (point))))
		      (error "ここには「]」がある筈!")))
		(error "ここには「[」がある筈!"))
	      (goto-char (1+ r))
	      (cal-process-command command str1))
	  (if (member command cal-command-2)
	      (progn
		;; in this case command has two args
		(goto-char end)
		(skip-chars-forward " \t\n")
		(if (= (following-char) ?\[)
		    (progn
		      (setq p (1+ (point)))
		      (forward-sexp 1)
		      (backward-char 1)
		      (if (= (following-char) ?\])
			  (progn
			    (setq q (point))
			    (goto-char p)
			    (cal-skip)
			    (setq p (point))
			    (goto-char q)
			    (cal-skip-back)
			    (setq str1 (list p (point))))
			(error "ここには「]」がある筈!")))
		  (error "ここには「[」がある筈!"))
		;; now check the second arg.
		(forward-char 1)
		(skip-chars-forward " \t\n")
		(if (= (following-char) ?\[)
		    (progn
		      (setq p (1+ (point)))
		      (forward-sexp 1)
		      (setq r (point))
		      (backward-char 1)
		      (if (= (following-char) ?\])
			  (progn
			    (setq q (point))
			    (goto-char p)
			    (cal-skip)
			    (setq p (point))
			    (goto-char q)
			    (cal-skip-back)
			    (setq str2 (list p (point))))
			(error "ここには「]」がある筈!")))
		  (error "このコマンドは引数が2個必要!"))
		(goto-char (1+ r))
		(cal-process-command command str1 str2))
	    (cal-report-error "cal-submit:"))))
    (error "実行すべきコマンドがありません！")))

(defun cal-process-command (command &optional arg1 arg2)
  "This function processes CAL commands. ARGS are list of two points, 
or can be strings if called from program."
  (let ((str1
	 (if arg1
	     (if (stringp arg1)
		 arg1
	       (buffer-substring-no-properties (car arg1) (car (cdr arg1))))
	   nil))
	(str2
	 (if arg2
	     (if (stringp arg2)
		 arg2
	       (buffer-substring-no-properties (car arg2) (car (cdr arg2))))
	   nil)))
    ;; for debug
    ;;(setq STR1 str1)
    ;; record args in log buffer
    (save-excursion
      (set-buffer (get-buffer-create " *CALLOG*"))
      (goto-char (point-max))
      (insert command)
      (if str1 (insert "[" str1 "]\n"))
      (if str2 (insert "[" str2 "]\n")))
    ;; first skip to the end of the command and args.
    (goto-char (cal-prompt-point))
    (if (null arg1)
	(end-of-line)
      (search-forward "\[" nil t)
      (backward-char 1)
      (forward-sexp 1)
      (if arg2
	  (progn
	    (search-forward "\[" nil t)
	    (backward-char 1)
	    (forward-sexp 1)))
      ;; backup one character, so that point will be looking at left bracket
      (forward-char -1))
    ;; call the command
    (cond ((and (null arg1) (member command cal-command-0))
	   (let ((fun (intern (concat "cal-" command))))
	     (apply fun '())))
	  ((and (null arg2) (member command cal-command-1))
	   (let ((fun (intern (concat "cal-" command))))
	     (apply fun (list str1))))
	  ((member command cal-command-2)
	   (let ((fun (intern (concat "cal-" command))))
	     (apply fun (list str1 str2))))
	  (t (cal-report-error "cal-process-command: ")))
    (unless cal-exit-flag
      (message "") ;; erase possible GC messages etc.
      (cal-clear-white)
      (cal-increment-prompt-count) )))

(defun cal-ok (str1) 
  (cal-insert (format "OK! 引数 = 「%s」" str1)))

(defun cal-comment (str)
  "Insert STR as a comment."
  (goto-char (cal-prompt-point))
  (if (search-forward "comment" nil t)
      (goto-char (match-end 0)))
  (delete-region (point) (point-max))
  (insert "\n")
  (cal-insert str))

(defun cal-bye ()
  (cal-exit))

(defun cal-defgame (name defs)
  "Define a game whose name is NAME and with the definitions DEFS.
The code is essentially the same as that of CAL-LOAD.  It is
strongly recommended to use this CAL command to develop new games,
and use CAL-LOAD to load only games defined by this command.  The dfined
game will be stored in the current game-dir."
  (let ((PEP nil))
    ;; DefPrimExpPat is defined in parser.el
    (let ((PrimExpPat DefPrimExpPat)
	  ;; if the game definition for NAME already exists,
	  ;; then rewrite it; otherwise, save the definition
	  ;; in the current game directory.
	  (file (or (cal-game-file name t)
		    (concat (car cal-game-dirs) name ".gm")))
	  (cts (current-time-string)))
      (message "導出ゲーム %s を定義しています．．．" name)
      (with-temp-buffer
	(insert defs)
	(cal-parse-defs name)
	(goto-char (point-min))
	(if (search-forward ";; defined by" nil t)
	    ;; old game
	    (let* ((date (substring cts 4 10))
		   (year (substring cts -4))
		   p
		   (str (progn
			  (end-of-line)
			  (setq p (point))
			  ;; 24 is the length of current-time-string
			  (buffer-substring-no-properties
			   (- (point) 24) (point))))
		   (date2 (substring str 4 10))
		   (year2 (substring str -4)))
	      (if (and (string= date date2)
		       (string= year year2))
		  ;; rewrite the current line
		  (progn
		    (beginning-of-line)
		    (delete-region (point) (min (point-max) (1+ p))))
		;; add a new line
		(beginning-of-line))
	      (insert 
	       (format ";; defined by %s at %s\n" (user-full-name) cts)))
	  ;; new game
	  (insert
	   (format ";; Derivation Game %s:\n;; defined by %s at %s\n\n"
		   name (user-full-name) cts)))
	(write-region (point-min) (point-max) file)))
    (setq PrimExpPat PEP)
    ;; that we are here means that parsing was successful,
    ;; so we set the name of the game by loading the gmc file.
    ;; we do this, so that we can evaluate elisp codes (eval-in-gmc ...)
    (cal-load-game name)
    (cal-set-current-game name)
    ;;(setq cal-games-in-play (parser-cons-if-new name cal-games-in-play))
    (message "")
    (cal-insert (format "導出ゲーム%sを定義しました" name))))

(defmacro eval-in-gmc (&rest form)
  "Evaluate FORM when this function is evaluate in the gmc file.
We use the dynamically bound variable SOURCE, which is bound when
cal-load-game is called."
  `(if (and (boundp 'source) (not source))
       (eval ,(list 'quote (cons 'progn form)))
     nil))

(defun cal-play (game &optional non-interactive)
  "Load GAME file if necessary and set CAL-CURRENT-GAME to GAME."
  (let ((file (cal-game-file game)))
    (if file
	(let ((PEP nil)
	      (cal-meta t)
	      (name-of-the-game game))
	  (load-file file)
	  (setq PrimExpPat PEP)
	  (cal-set-current-game game)
	  (message "")
	  (unless non-interactive
	    (cal-insert (format "Let's play %s!" game))))
      (if non-interactive
	  ;; just return nil
	  nil
	(error "導出ゲーム %s は未定義です" game)))))

(defun cal-game-file (game &optional source)
  "Find full file name for the GAME.  If SOURCE, retun .gm file."
  (let ((dirs cal-game-dirs)
	(full-name nil)
	(cont t))
    (while (and dirs cont)
      (setq dir (car dirs))
      (if (file-exists-p (concat dir game ".gmc"))
	  (setq full-name (concat dir game (if source ".gm" ".gmc"))
		cont nil)
	(setq dirs (cdr dirs))))
    full-name))

(defun cal-current-game-file ()
  "Compute the file name for the CAL-CURRENT-GAME"
  (cal-game-file cal-current-game t))

(defun cal-tokens ()
  "Print the regexps for the tokens of CAL-CURRENT-GAME."
  (let (file str)
    (if cal-current-game
	(setq file (cal-current-game-file))
      (error "現在プレイ中の導出ゲームはありません"))
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (if (search-forward cal-deftokens-string nil t)
	  (progn
	    (backward-char 1)
	    (setq str (cal-arg-region t)))
	(error "導出ゲーム %s には固有のトークン定義がありません" cal-current-game)))
    (cal-insert str)))

(defun cal-syntax ()
  "Print the syntax of CAL-CURRENT-GAME."
  (let (file str)
    (if cal-current-game
	(setq file (cal-current-game-file))
      (error "現在プレイ中の導出ゲームはありません"))
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (if (search-forward cal-defsyntax-string nil t)
	  (progn
	    (backward-char 1)
	    (setq str (cal-arg-region t)))
	(error "導出ゲーム %s には固有の構文定義がありません" cal-current-game)))
    (cal-insert str)))

(defun cal-rules ()
  "Print the inference rules of CAL-CURRENT-GAME."
  (let (file str)
    (if cal-current-game
	(setq file (cal-current-game-file))
      (error "現在プレイ中の導出ゲームはありません"))
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (if (search-forward cal-defrules-string nil t)
	  (progn
	    (backward-char 1)
	    (setq str (cal-arg-region t)))
	(error "導出ゲーム %s には固有の推論規則がありません" cal-current-game)))
    (cal-insert str)))

(defun cal-tex (tt)
  "Parse CAL-DERIV-STR as tex-derivation and process the result by
platex and xdvi."
  (when (null cal-deriv-str) (error "チェック済の導出はありません"))
  (let ((tex-dir (concat cal-dir "text/"))
	META-VARS)
    (let ((file (concat tex-dir "CALTEX.tex")))
      (if (file-exists-p file) (cal-call-process "rm" file)))
    (let ((file (concat tex-dir "CALTEX.dvi")))
      (if (file-exists-p file) (cal-call-process "rm" file)))
    (with-temp-buffer
      (let ((source 
	     (concat "\\[\n"
		     (second (let ((caltex-tt-var tt) (vertical t)) 
			       (ParseString cal-deriv-str 'tex-derivation)))
		     "\\]\n")))
	(insert-file-contents (concat tex-dir "cal-tex.tex"))
	(goto-char (point-min))
	(search-forward "begin{document}")
	(end-of-line)
	(forward-char 1)
	(insert source)
	(write-file (concat tex-dir "CALTEX.tex"))))
    (cd tex-dir)
    (cal-call-process "platex" (concat tex-dir "CALTEX.tex"))
    (cal-call-process 
     "xdvi" "-expert" "-s" "6" "-offset" "0cm" "-geometry" "660x500"
     (concat tex-dir "CALTEX.dvi"))))

(defun cal-textt ()
  (cal-tex t))

(defun cal-texit ()
  (cal-tex nil))

(defun cal-texrule (rule)
  "Run TeX and show RULE."
  (unless cal-current-game
    (error "プレイ中のゲームがありません"))
  (caltex-play cal-current-game)
  (let ((tex-dir (concat cal-dir "text/"))
	META-VARS)
    (let ((file (concat tex-dir "CALTEX.tex")))
      (if (file-exists-p file) (cal-call-process "rm" file)))
    (let ((file (concat tex-dir "CALTEX.dvi")))
      (if (file-exists-p file) (cal-call-process "rm" file)))
    (with-temp-buffer
      (let ((source 
	     (concat "\\[\n"
		     (caltex-parse-rule rule)
		     "\\]\n")))
	(insert-file-contents (concat tex-dir "cal-tex.tex"))
	(goto-char (point-min))
	(search-forward "begin{document}")
	(end-of-line)
	(forward-char 1)
	(insert source)
	(write-file (concat tex-dir "CALTEX.tex"))))
    (cd tex-dir)
    (cal-call-process "platex" (concat tex-dir "CALTEX.tex"))
    (cal-call-process 
     "xdvi" "-expert" "-s" caltex-size 
     "-offset" "0cm" "-geometry" (caltex-geometry)
     (concat tex-dir "CALTEX.dvi"))))

(defun cal-texrules ()
  "TeX all the rules of the current game.  We assume that caltex-play is
called with the current game."
  (caltex-play cal-current-game)
  (let ((tex-dir (concat cal-dir "text/"))
	META-VARS)
    (let ((file (concat tex-dir "CALTEX.tex")))
      (if (file-exists-p file) (cal-call-process "rm" file)))
    (let ((file (concat tex-dir "CALTEX.dvi")))
      (if (file-exists-p file) (cal-call-process "rm" file)))
    (save-excursion
      (set-buffer "*caltex*")
      (goto-char (point-min))
      (if (re-search-forward "^rules\\[")
	  (let (p q (r-list nil))
	    (goto-char (1- (match-end 0)))
	    (setq p (point))
	    (forward-sexp)
	    (setq q (1- (point)))
	    (goto-char p)
	    (while (re-search-forward "^[ \t]*\"\\([^\"]*\\)" q t)
	      (setq r-list (cons (buffer-substring 
				  (match-beginning 1) (match-end 1))
				 r-list)))
	    (with-temp-buffer
	      (let ((source ""))
		(while r-list
		  (setq source
			(concat
			 (concat "\\[\n"
				 (caltex-parse-rule (car r-list))
				 "\\]\n\n")
			 source))
		  (setq r-list (cdr r-list)))
		(setq source 
		      (concat
		       (format 
			"{\\large\\bf Rules of the derivation game {\\tt %s}}\n"
			cal-current-game)
		       "\\bigskip\n"
		       source))
		(insert-file-contents (concat tex-dir "cal-tex.tex"))
		(goto-char (point-min))
		(search-forward "begin{document}")
		(end-of-line)
		(forward-char 1)
		(insert source)
		(write-file (concat tex-dir "CALTEX.tex"))))
	    (cd tex-dir)
	    (cal-call-process "platex" (concat tex-dir "CALTEX.tex"))
	    (cal-call-process 
	     "xdvi" "-expert" "-s" caltex-size 
	     "-offset" "0cm" "-geometry" (caltex-geometry)
	     (concat tex-dir "CALTEX.dvi")))
	(error "導出ゲーム %s は規則がありません" cal-current-game)))))

(defun cal-check (str1 &optional check-only)
  "Check if STR1 is a correct derivation." 
  (let* ((re-pattern 
	  "[ \\|\t\\|\n]in[ \\|\t\\|\n]*\\([a-zA-Z][a-zA-Z0-9_]*\\)[ \\|\t\\|\n]*since[ \\|\t\\|\n]")
	 (game
	  (let ((case-fold-search nil))
	    (if (string-match re-pattern str1)
		(substring str1 (match-beginning 1) (match-end 1)))))
	 (beg (match-beginning 1))
	 (end (match-end 1)))
    (if game 
	(if (string= game cal-current-game)
	    ;; ok, fine
	    nil
	  ;; current game is not the GAME, so call CAL-PLAY
	  ;; non-interactively. 
	  (if (null cal-current-game)
	      (error "現在プレイ中のゲームはありません")
	    (cal-set-epos beg end)
	    (error "導出で指定したゲーム %s とプレイ中のゲーム %s が一致しません"
		   game cal-current-game)))
      (error 
       "導出に必要なキーワード「in」と「since」が正しい位置にありません"))
    (when (and (cal-check-derivation str1) (not check-only))
      (cal-insert
       (format "たしかに導出ゲーム %s の正しい導出です．" game))
      (setq cal-demo-command nil))))

(defun cal-Definition (str1 str2)
  "Register a new definition.  STR1 must be of the form 
NAME(VAR,...,VAR) and STR2 must be an expression under 
VAR,...,VAR and it must be a propsition of the current game."
  (let* ((tree1 
	  (ParseString str1 
		       '(prefix var (paren "(" (list var ",")))))
	 (name (second (first tree1)))
	 (defname (concat cal-current-game ":" name))
	 (vars (second tree1))
	 (tree2 (ParseString str2 'prop)))
    (nf-sublist (nf-vars tree2) vars)
    (when (= (length name) 1)
      (error "定義に用いる名前は2文字以上でないといけません!"))
    (put (intern defname) 'cal-def (list vars tree2))
    (setq cal-def-list
	  (cons (list defname vars tree2) cal-def-list)) 
    (cal-update-list 'cal-def-str-list cal-current-game 
		     (list str1 str2))
    (cal-update-list 'cal-game-ops cal-current-game name)
    (parser-extend-prim-exp-pat name)
    (cal-insert (format "述語 %s を定義しました" name))))

(defun cal-Theorem (name str)
  "Register a new theorem.  NAME must be a variable, which is made into
an op.  STR must be a valid derivation in the current game."
  (ParseString name 'var)
  (cal-check str t)
  (let* ((tree (ParseString str 'derivation))
	 (context (exp-derivation-context tree))
	 (concl (nf-schematize (exp-derivation-concl tree)))
	 (deriv (exp-derivation-deriv tree))
	 (vars (mapcar (lambda (item) (intern (second item))) (nf-gc context)))
	 (hyps (nf-schematize (nf-hyps context)))
	 (game (intern cal-current-game))
	 ;;(thm-data (cons name (cons vars (cons concl hyps))))
	 (thm-data (cons name (list vars (cons concl hyps) deriv)))
	 (thm-list (get game 'thm-list))
	 thm-str)
    (setq thm-list
	  (cons  thm-data thm-list))
    (put game 'thm-list thm-list)
    (cal-update-list 'cal-thm-list cal-current-game thm-data)
    (if (string-match (concat "[ \t\n]+in[ \t\n]+" cal-current-game) str)
	(setq thm-str (substring str 0 (match-beginning 0)))
      (error "Implementation error: cal-Theorem"))
    (cal-update-list 'cal-thm-str-list cal-current-game 
		     (list name (cal-convert-hypj-to-condj thm-str)))
    (cal-update-list 'cal-game-ops cal-current-game name)
    (parser-extend-prim-exp-pat name)
    (cal-insert (format "定理 %s を登録しました" name))))

(defun cal-list-theorems ()
  "List theorems in the current game."
  (let ((thm-list (second (assoc cal-current-game cal-thm-str-list))))
    (if (null thm-list)
	(cal-insert (format "導出ゲーム %s の定理はありません" cal-current-game))
      (while thm-list
	(let* ((item (first thm-list))
	       (name (first item))
	       (hyp (first (second item)))
	       (hyp-str "")
	       (concl (second (second item))))
	  (while hyp
	    (setq hyp-str (concat hyp-str (first hyp)))
	    (setq hyp (cdr hyp))
	    (when hyp (setq hyp-str (concat hyp-str ", "))))
	  (cal-insert (format "定理 %s:  %s ⇒ %s" name hyp-str concl))
	  (setq thm-list (cdr thm-list)))))))

(defun cal-list-definitions ()
  "List definitions in the current game."
  (let ((def-list (second (assoc cal-current-game cal-def-str-list))))
    (if (null def-list)
	(cal-insert (format "導出ゲーム %s での述語定義はありません" cal-current-game))
      (while def-list
	(let* ((item (first def-list))
	       (name (first item))
	       (body (second item)))
	  (cal-insert (format "定義 %s:  %s" name body))
	  (setq def-list (cdr def-list)))))))

(defun cal-remove-definition (name &optional silent)
  "Remove NAME from definition and also remove definitions and
theorems which depend on it."
  (let ((inhibit-quit t)
	(defname (concat cal-current-game ":" name)))
    (if (get (intern defname) 'cal-def)
	(let* ((r-def-list (reverse cal-def-list))
	       (def-str-triple 
		 (cal-split-list cal-def-str-list cal-current-game))
	       (def-str-pre (first def-str-triple))
	       (r-def-str-list (reverse (second (second def-str-triple))))
	       (def-str-post (third def-str-triple))
	       (thm-triple
		 (cal-split-list cal-thm-list cal-current-game))
	       (thm-pre (first thm-triple))
	       (r-thm-list (reverse (second (second thm-triple))))
	       (thm-post (third thm-triple))
	       (thm-str-triple
		 (cal-split-list cal-thm-str-list cal-current-game))
	       (thm-str-pre (first thm-str-triple))
	       (r-thm-str-list (reverse (second (second thm-str-triple))))
	       (thm-str-post (third thm-str-triple))
	       (new-def-list nil)
	       (new-def-str-list nil)
	       (new-thm-list nil)
	       (new-thm-str-list nil)
	       (ops (list (list 'op name)))
	       (found nil))
	  (while r-def-list
	    (let* ((item (first r-def-list))
		   (full-name (first item))
		   (body (cdr item))
		   (item-str (first r-def-str-list)))
	      (if (string= full-name defname)
		  ;; found def for NAME, so just remove it by not adding item
		  ;; to NEW-DEF-LIST. also remove it from property list
		  (progn
		    (put (intern full-name) 'cal-def nil)
		    (setq found t))
		(if found
		    ;; check if BODY intersects OPS
		    (if (nf-intersect-p body ops)
			;; remove it, and add NAME to ops
			(progn
			  (put (intern full-name) 'cal-def nil)
			  (setq ops 
				(cons (list 'op
					    (second 
					     (cal-split-str full-name ":")))
				      ops)))
		      ;; since ITEM does not depend on OPS, keep it
		      (setq new-def-list (cons item new-def-list)
			    new-def-str-list (cons item-str new-def-str-list)))
		  ;; keep it
		  (setq new-def-list (cons item new-def-list)
			new-def-str-list (cons item-str new-def-str-list))))
	      (setq r-def-list (cdr r-def-list)
		    r-def-str-list (cdr r-def-str-list))))
	  ;; now check theorems
	  (while r-thm-list
	    (let* ((item (first r-thm-list))
		   (thm-name (first item))
		   ;; chop off vars
		   (body (cdr (cdr item)))
		   (item-str (first r-thm-str-list)))
	      ;; check if BODY intersects OPS
	      (if (nf-intersect-p body ops)
		  ;; remove it, and add NAME to ops
		  (setq ops (cons (list 'op thm-name) ops))
		;; since ITEM does not depend on OPS, keep it
		(setq new-thm-list (cons item new-thm-list)
		      new-thm-str-list (cons item-str new-thm-str-list)))
	      (setq r-thm-list (cdr r-thm-list)
		    r-thm-str-list (cdr r-thm-str-list))))
	  (put (intern cal-current-game) 'thm-list new-thm-list)
	  (setq cal-def-list new-def-list)
	  (setq cal-def-str-list
		(append def-str-pre 
			(list (list cal-current-game new-def-str-list))
			def-str-post))
	  (setq cal-thm-list
		(append thm-pre 
			(list (list cal-current-game new-thm-list))
			thm-post))
	  (setq cal-thm-str-list
		(append thm-str-pre 
			(list (list cal-current-game new-thm-str-list))
			thm-str-post))
	  ;; remove ops from PrimExpPat
	  (let ((pep PrimExpPat))
	    (while ops
	      (let* ((op-str (concat (second (first ops)) "\\|"))
		     (pair (cal-split-str pep op-str)))
		(setq pep (concat (first pair) (second pair)))
		(setq ops (cdr ops))))
	    (setq PrimExpPat pep))
	  (unless silent (cal-insert (format "述語定義「%s」を除去しました" name))))
      (unless silent 
	(cal-insert (format "「%s」は述語として定義されていません" name))))))

(defun cal-remove-theorem (name &optional silent)
  "Remove NAME from theorem and also remove theorems which depend on it."
  (let* ((inhibit-quit t)
	 (thm-triple
	  (cal-split-list cal-thm-list cal-current-game))
	 (thm-pre (first thm-triple))
	 (r-thm-list (reverse (second (second thm-triple))))
	 (thm-post (third thm-triple))
	 (thm-str-triple
	  (cal-split-list cal-thm-str-list cal-current-game))
	 (thm-str-pre (first thm-str-triple))
	 (r-thm-str-list (reverse (second (second thm-str-triple))))
	 (thm-str-post (third thm-str-triple))
	 (new-thm-list nil)
	 (new-thm-str-list nil)
	 (ops (list (list 'op name)))
	 (found nil))
    ;; now check theorems
    (while r-thm-list
      (let* ((item (first r-thm-list))
	     (thm-name (first item))
	     ;; chop off vars
	     (body (cdr (cdr item)))
	     (item-str (first r-thm-str-list)))
	(if found
	    ;; check if BODY intersects OPS
	    (if (nf-intersect-p body ops)
		;; remove it, and add NAME to ops
		(setq ops (cons (list 'op thm-name) ops))
	      ;; since ITEM does not depend on OPS, keep it
	      (setq new-thm-list (cons item new-thm-list)
		    new-thm-str-list (cons item-str new-thm-str-list)))
	  (if (string= thm-name name)
	      ;; found it, so remove it by doing nothing
	      (setq found t)
	    ;; keep it
	    (setq new-thm-list (cons item new-thm-list)
		  new-thm-str-list (cons item-str new-thm-str-list))))
	(setq r-thm-list (cdr r-thm-list)
	      r-thm-str-list (cdr r-thm-str-list))))
    (if found
	(progn
	  (put (intern cal-current-game) 'thm-list new-thm-list)
	  (setq cal-thm-list
		(append thm-pre 
			(list (list cal-current-game new-thm-list))
			thm-post))
	  (setq cal-thm-str-list
		(append thm-str-pre 
			(list (list cal-current-game new-thm-str-list))
			thm-str-post))
	  ;; remove ops from PrimExpPat
	  (let ((pep PrimExpPat))
	    (while ops
	      (let* ((op-str (concat (second (first ops)) "\\|"))
		     (pair (cal-split-str pep op-str)))
		(setq pep (concat (first pair) (second pair)))
		(setq ops (cdr ops))))
	    (setq PrimExpPat pep))
	  (unless silent (cal-insert (format "定理「%s」を除去しました" name))))
      (unless silent (cal-insert (format "「%s」は定理として登録されていません" name))))))

;; functions for checking answers

(defun cal-check-game (game)
  "Check if the user is currently playing the GAME."
  (if cal-current-game
      (if (string= game cal-current-game)
	  t
	(error "play[%s] でプレイ中のゲームを %s にしてから解答してください" game game)) 
    (error "play[%s] でプレイ中のゲームを %s にしてから解答してください" game game)))

(defun cal-match-deriv (game pat str)
  "Check if the user is currently playing the GAME and then check if
STR is a correct instance of PAT which is given by a string containing
meta variables."
  (and (cal-check-game game)
       (cal-check-derivation str)
       (let ((result
	      (catch 'fail 
		(nf-match-simple (ParseString pat 'meta-derivation)
				 (ParseString str 'derivation)))))
	 ;; for debug
	 ;;(setq RESULT result)
	 (if (stringp result)
	     nil
	   t))))

(defun cal-parse (class str)
  "Parse STR as CLASS."
  (cal-insert (format "%s" (ParseString str (intern class)))))

(defun cal-demo (file)
  "Process cal commands in FILE one by one in the *cal* buffer.
This function initiate the demo session in the *cal* buffer.
The session will be terminated when the commands in the file
has been exhausted and this will be taken care of by CAL-RETURN."
  (if (string= file "")
      (progn
	(when (get-buffer " *CALDEMO*")
	  (save-excursion
	    (set-buffer " *CALDEMO*")
	    (erase-buffer)))
	(when cal-demo-on
	  (setq cal-game-dirs cal-saved-game-dirs
		cal-current-game cal-saved-current-game
		cal-demo-on nil
		cal-demo-command nil)
	  (cal-play cal-current-game t))
	(cal-insert "デモは終了しました．"))
    (let (str (full-name (concat cal-demo-dir file)))
      (if (file-exists-p full-name)
	  (progn
	    (save-excursion
	      (set-buffer (get-buffer-create " *CALDEMO*"))
	      (insert-file-contents full-name)
	      (when (looking-at "CAL session started")
		;; this is a CALLOG file, so remove unnecessary lines,
		;; modify "]\n[" to "][\n", and
		;; remove the bye command
		(save-excursion
		  (let ((p (point)))
		    (when (re-search-forward "^bye$" nil t)
		      (delete-region (match-beginning 0) (match-end 0)))
		    (goto-char p)
		    (while (search-forward "\n[" nil t)
		      (goto-char (match-beginning 0))
		      (delete-char 2)
		      (insert "[\n"))
		    (goto-char p)
		    ;; first remove the following 6 lines
		    ;;
		    ;; CAL session started
		    ;; at: Tue Nov 18 20:20:31 2003
		    ;; on: debian
		    ;; by: masahiko (Masahiko Sato)
		    ;; -----
		    ;; Prop <1>
		    ;;
		    (forward-line 6)
		    (delete-region p (point))
		    (while (re-search-forward "^-----" nil t)
		      ;; now the current line and the following line 
		      ;; looks like:
		      ;;
		      ;; -----
		      ;; Prop <1> Sat Nov 22 22:58:23 2003
		      ;;
		      ;; so remove these two lines
		      (setq p (- (point) 5))
		      (forward-line 2)
		      (delete-region p (point)))
		    ;; now there is one more line to be killed, namely:
		    ;;
		    ;; at: Sun Nov 23 11:22:43 2003
		    (setq p (point))
		    (forward-line 1)
		    (delete-region p (point)))))
	      (when cal-demo-on
		;; if cal-demo-on, we need a white space
		(insert "\n")
		(backward-char)))
	    (cal-insert (format "デモファイル %s のコマンドを実行します." full-name))
	    (cal-clear-white) 
	    (goto-char (point-max))
	    (when (not cal-demo-on)
	      (setq cal-saved-game-dirs cal-game-dirs
		    cal-saved-current-game cal-current-game))
	    (setq cal-demo-on t)
	    (setq cal-demo-command t))
	(error "デモファイル %s が見つかりません" full-name)))))

(defun cal-get-a-command ()
  "Search for a cal command string, and return it if found,
othewise return nil.  We assume that the first bracket of the first
argument of the command is on the same line as the command."
  (let (p)
    (save-excursion
      (set-buffer " *CALDEMO*")
      (skip-chars-forward " \t\n")
      (setq p (point))
      (if (eobp)
	  ;; we don't have a command any more
	  nil
	(let ((q (save-excursion (end-of-line) (point))))
	  (if (search-forward "[" q t)
	      (progn
		(backward-char)
		(forward-sexp)
		(when (looking-at "[ \t\n]*\\[")
		  ;; two args command, so foward-sexp again
		  ;; first remove redundant white spaces
		  (delete-region (match-beginning 0) (1- (match-end 0)))
		  (forward-sexp))
		;; we have just found an entire command
		(buffer-substring-no-properties p (point)))
	    ;; we must have a nullary command
	    (skip-chars-forward "^ \t\n")
	    (buffer-substring-no-properties p (point))))))))

(defun cal-check-solved (no)
  (or (member no *csl*)
      (error "この問題に解答するためには Q[%s] が解けている必要があります"
	     no)))

(defun cal-check-first-arg (command arg1)
  "Given ARG1 of two args COMMAND, check if ARG1 is ok.
ARG1 is either a string or a region."
  (let ((str1
	 (if (stringp arg1)
	     arg1
	   (buffer-substring (car arg1) (car (cdr arg1))))))
    (cond ((string= command "A")
	   ;; check if ARG1 is between 1 and cal-no-of-problems
	   (let ((num (string-to-int str1)))
	     (if (or (>= 0 num) (> num cal-no-of-problems))
		 (error "最初の引数は 1 と %d の間の数でないといけません!"
			cal-no-of-problems))
	     t))
	  ((string= command "defgame")
	   ;; check if the game STR1 is already defined
	   (let ((file (cal-game-file str1 t)))
	     (if (and
		  file
		  (if (file-writable-p file)
		      t
		    (error "ゲーム「%s」は書き換えできません" str1))
		  (save-excursion (cal-skip) (eobp)))
		 (if (yes-or-no-p
		      (format "ゲーム「%s」は既に存在します．書き換えますか?  " str1))
		     ;; ok, go ahead.  we supply the contents of the file
		     (progn
		       (insert "\n")
		       (insert-file-contents file)
		       t)
		   (backward-char 1)
		   (delete-char 1)
		   (error ""))
	       ;; ok
	       t)))
	  ((string= command "Definition")
	   t)
	  ((string= command "Theorem")
	   t)
	  ((string= command "check")
	   t)
	  ((or (string= command "parse") 
	       (string= command "defeq")
	       (string= command "inclass"))
	   (if (or
		(get (intern str1) 'rule)
		(memq (intern str1) PrimClass))
	       t
	     (error "%s は構文のクラスとして定義されていません" str1)))
	  ((string= command "rename-theorem")
	   t)
	  ((string= command "set")
	   (let ((var
		  (MkTokenList (ReadToken (car arg1) (car (cdr arg1)))))
		 (var-str (buffer-substring (car arg1) (second arg1))))
	     (if (not (= (length var) 1))
		 (error "第1引数は変数でないといけません!"))
	     t))
	  ((string= command "check-syntax")
	   (if (string= str1 "")
	       (error "第1引数は空でない文字列でないといけません!"))
	   t)
	  ((string= command "check-deriv")
	   (if (or (string= str1 "hyp-seq")
		   (string= str1 "arith-term")
		   (string= str1 "prop-form")
		   (string= str1 "prop-proof"))
	       t
	     (error "%s はチェックできません!" str1)))
	  (t (cal-report-error "cal-check-first-arg: ")))))

(defun cal-Q (&optional str1)
  "print the problems specified by STR1.  if STR1 is nil, just compute
the number of problems."
  (let (p q
	  pstr;; the string of the problem
	  ;; m;; index of the last problem
	  )
    (save-excursion
      (set-buffer (get-buffer-create " *PROBLEMS*"))
      (if (= (buffer-size) 0) 
	  (unless (cal-download cal-P-file "problems ends here")
	    (error "問題ファイルの取得に失敗しました．教官かTAに連絡してください．")))
      (setq cal-no-of-problems (cal-max-no))
      (if (null str1)
	  ;; nothing to do anymore
	  nil
	(if (string= str1 "")
	    nil
	  (setq pstr (car (cal-substring str1)))
	  )))
    (if (null str1)
	;; just return cal-no-of-problems
	cal-no-of-problems
      (if (string= str1 "")
	  (cal-insert (format "現時点での問題の総数は %s 題です."
			      cal-no-of-problems))
	(end-of-line)
	(insert "\n\n")
	(cal-insert-lines pstr)))))

(defun cal-A (str1 str2)
  "check if STR2 is a correct answer to the quetstion no STR1." 
  (let (p
	astr ;; answer string
	cstr ;; commentary string
	(correct nil) ;; will be set to t if answer is correct
	(noprob nil) ;; will be set to t if the problem not found
	val ;; resulting value of eval-region
	)
    (when (> (string-to-number str1) 1)
	;; check if Q[1] has been solved
	(or (member 1 *csl*)
	    (error
	     "Q[1] に解答しないと他の問題は解答できません．")) )
    (save-excursion
      (set-buffer (get-buffer-create " *ANSWERS*"))
      (if (= (buffer-size) 0) 
	  (unless (cal-download cal-A-file "answers ends here")
	    (error "解答ファイルの取得に失敗しました．教官かTAに連絡してください．")))
      (goto-char (point-min))
      (if (search-forward (concat "-----\n[" str1 "]") nil t)
	  (progn
	    (forward-char 1)
	    (if (looking-at ";; ")
		(progn
		  ;; in this case, we compute the answer by
		  ;; evaluating the program written in this line.
		  (forward-char 3)
		  (setq p (point))
		  (end-of-line)
		  (eval-region p (point))
		  (setq correct val))
	      (setq p (point))
	      (end-of-line)
	      (setq correct
		    (string= str2 (buffer-substring p (point)))))
	    (or (looking-at "\n-----")
		;; we have commentary lines
		(progn
		  (forward-char 1)
		  (setq p (point))
		  (end-of-line)
		  (search-forward "\n-----")
		  (setq cstr
			(buffer-substring
			 p
			 (1+ (match-beginning 0)))))))
	(setq noprob t)))
    (if noprob
	(progn
	  (goto-char (cal-prompt-point))
	  (search-forward "\[" nil t)
	  (error "番号 %s の問題はありません!" str1))
      (if correct
	  (progn 
	    (save-excursion
	      (set-buffer (get-buffer-create " *CALLOG*"))
	      (write-region (point-min) (point-max) 
			    (concat my-cal-session-log-file
				    (int-to-string cal-session-count))
			    nil 0)
	      (when cal-session-log-file
		(let ((file (concat cal-session-log-file
				    (int-to-string cal-session-count))))
		  (write-region (point-min) (point-max) file nil 0)
		  (cal-call-process cal-chmod "660" file))))
	    ;; check if already solved the same problem
	    (or (member (string-to-number str1)
			*csl*)
		(progn
		  (setq *csl*
			(cons (string-to-number str1)
			      *csl*))
		  ;; dont send reports any more
		  ;;(cal-mail-to-report (format "Problem [%s]" str1) "")
		  ))
	    (if cstr (cal-insert-lines cstr)
	      (cal-insert "正解!")))
	(error "間違いです!")))))

(defun cal-solved ()
  (if *csl*
      (cal-insert-lines
       (format "解答済の問題は以下の通りです.\n%s\n"
	       (sort (copy-sequence *csl*) '<)))
    (cal-insert "解答済の問題はありません. 頑張ってね!")))

(defun cal-unsolved (&optional non-interactive)
  "compute the list of unsolved problems and print it.  if NON-INTERACTIVE
just return the list."
  ;; call cal-Q if necessary to compute cal-no-of-problems
  (or cal-no-of-problems (cal-Q nil))
  (let ((list nil) (no cal-no-of-problems))
    (while (> no 0)
      (if (not (member no *csl*))
	  (setq list (cons no list)))
      (setq no (1- no)))
    (if non-interactive
	list
      (if *csl*
	  (if list
	      (cal-insert-lines
	       (format "未解答の問題は以下の通りです.\n%s\n" list))
	    (cal-insert
	     "現時点で未解答の問題はありません(^_^)"))
	(cal-insert
	 (format "解答済の問題はありません. 頑張ってね! 問題は全部で %s 題あります."
		 cal-no-of-problems))))))

(defun cal-get-news ()
  "Get news from the server"
  (save-excursion
    (set-buffer (get-buffer-create " *NEWS*"))
    (cal-download cal-N-file "news ends here")))

(defun cal-news (str)
  "compute news string detemined by the interval STR.  If STR is nil,
just compute the index of the latest news.  If STR is \"\",
compute all the unread news. updates cal-news-list as well."
  (let (p q
	  nstr;; the string of the problem
	  m
	  min-max
	  )
    (if (string= str "")
	(if (= (length cal-news-list) cal-no-of-news)
	    (cal-insert-lines "未読のニュースはありません.")
	  (let ((n 1))
	    (while (<= n cal-no-of-news)
	      (if (member n cal-news-list)
		  (setq n (1+ n))
		(setq cal-news-list (cons n cal-news-list))
		(cal-news (int-to-string n))
		(setq n (1+ n))))))
      (save-excursion
	(set-buffer (get-buffer-create " *NEWS*"))
	(if str
	    (let ((triple (cal-substring str)))
	      (setq nstr (car triple)
		    min-max (cdr triple)))
	  (setq m (cal-max-no))))
      (if str
	  (progn
	    (cal-insert-lines nstr)
	    (let ((min (car min-max))
		  (max (second min-max)))
	      (while (<= min max)
		(setq cal-news-list (cal-cons min cal-news-list))
		(setq min (1+ min)))))
	m))))

(defun cal-record (str1)
  (let ((inhibit-quit t)
	p
	nstr;; the string of the problem
	m ;; index of the latest news
	;;(today (cjal-today))
	)
    (save-excursion
      (set-buffer (get-buffer-create " *RECORD*"))
      (if (= (buffer-size) 0) 
	  (unless (cal-download cal-R-file "CAL record")
	    (error 
	     "記録のファイルのダウンロードに失敗しました．教官かTAに連絡してください．")))
      (goto-char (point-max))
      ;; 行頭で以下のパターンの日付を探す
      (if (re-search-backward "^\\[\\([0-9]*.[0-9]*\\)\\]" nil t)
	  (setq m (buffer-substring (match-beginning 1) (match-end 1))))
      (if (string= str1 "") (setq str1 m))
      (goto-char (point-min))
      (if (re-search-forward (concat "^\\[" (regexp-quote str1) "\\]") nil t)
	  (progn
	    (end-of-line)
	    (forward-char 1)
	    (setq p (point))
	    (search-forward "\n-----")
	    (beginning-of-line)
	    (setq nstr (buffer-substring p (point))))
	(error "日付 %s の記録はありません. 最新の記録は[%s]." str1 m)))
    (end-of-line)
    (if m (insert (format "\n(最新の記録は record[%s] で.)" m)))
    (cal-insert-lines nstr)))

(defun cal-myrecord (str1)
  (let (p
	nstr;; the string of the record
	m ;; index of the latest date in myrecord
	  )
    (save-excursion
      (set-buffer (get-buffer-create " *MYRECORD*"))
      (if (= (buffer-size) 0)
	  (insert-file-contents (concat cal-log-dir "myrecord")))   
      (goto-char (point-max))
      (re-search-backward "^\\([0-9]*.[0-9]*\\)" nil t)
      (setq m (buffer-substring (match-beginning 1) (match-end 1)))
      (if (string= str1 "") (setq str1 m))
      (goto-char (point-min))
      (if (search-forward (concat str1 " ") nil t)
	  (progn
	    (beginning-of-line)
	    (setq p (point))
	    (end-of-line)
	    (setq nstr (buffer-substring p (point))))
	(error
	 "日付 %s の記録はありません. 最新の記録は[%s]." str1 m)))
    (setq p (point))
    (end-of-line)
    (insert (format "\n(最新の記録は myrecord[%s] で.)" m))
    (cal-insert-lines
     (concat
      "日付   順位/総数  解答数/問題数  (平均解答数)  総得点  login-name\n"
      "-----------------------------------------------------------------\n"
      nstr))))

(defun cal-help (command)
  (let (p q str)
    (if (string= "" command) (setq command "help"))
    (save-excursion
      (set-buffer (get-buffer-create " *HELP*"))
      (when (= (buffer-size) 0)
	(unless (cal-download cal-H-file "help ends here")
	  (error "Help file の取得に失敗しました．教官かTAに連絡してください．")))
      (goto-char (point-min))
      (if (search-forward (concat "-----\n[" command "]") nil t)
	  (progn
	    (end-of-line)
	    (forward-char 1)
	    (setq p (point))
	    (search-forward "\n-----")
	    (beginning-of-line)
	    (setq str (buffer-substring p (point))))
	;; STR1 is nonlocal
	(error "%s のヘルプはありません!" command)))
    (cal-insert str)))

;; game specific functions

(defun cal-rd-p (deriv)
  "Check if DERIV contains a redex. See PropRed.gm."
  (cond ((exp-varref-p deriv) nil)
	((= (length deriv) 2)
	 ;; DERIV = (var (Abs vars map body))
	 (let ((body (fourth (second deriv))))
	   (cal-rd-p body)))
	((= (length deriv) 4)
	 ;; DERIV = (Abs vars map body)
	 (let ((body (fourth deriv)))
	   (cal-rd-p body)))
	((= (length deriv) 3)
	 ;; rule-deriv
	 (let ((rule-name (second (second deriv)))
	       (subderivs (third deriv)))
	   (cond ((or (string= rule-name "∧-EL") (string= rule-name "∧-ER"))
		  (let ((d (first subderivs)))
		    (if (and (= (length d) 3)
			     (string= (second (second d)) "∧-I"))
			t
		      (cal-rd-p d))))
		 ((string= rule-name "⊃-E")
		  (let ((d (first subderivs)))
		    (if (and (= (length d) 3)
			     (string= (second (second d)) "⊃-I"))
			t
		      (or (cal-rd-p d)
			  (cal-rd-p (second subderivs))))))
		 ((string= rule-name "∨-E")
		  (let ((d (first subderivs)))
		    (if (and (= (length d) 3)
			     (or (string= (second (second d)) "∨-IL")
				 (string= (second (second d)) "∨-IR")))
			t
		      (or (cal-rd-p d)
			  (cal-rd-p (second subderivs))
			  (cal-rd-p (third subderivs))))))
		 ((string= rule-name "⊥-E")
		  (let ((d (first subderivs)))
		    (if (and (= (length d) 3)
			     (string= (second (second d)) "⊥-I"))
			t
		      (cal-rd-p d))))
		 ((string= rule-name "⇒-E")
		  (let ((d (first subderivs)))
		    (if (= (length d) 2)
			t
		      (or (cal-rd-p d)
			  (cal-rd-p (second subderivs))))))
		 ((string= rule-name "U-E")
		  (let ((d (first subderivs)))
		    (if (eq 'Abs (first d))
			t
		      (cal-rd-p d))))
		 ((string= rule-name "∧-I")
		  (or (cal-rd-p (first subderivs))
		      (cal-rd-p (second subderivs))))
		 ((or (string= rule-name "⊃-I")
		      (string= rule-name "∨-IL")
		      (string= rule-name "∨-IR")
		      (string= rule-name "⊥-I"))
		  (cal-rd-p (first subderivs))))))
	))

(defun cal-rt-p (term)
  "Check if TERM contains a redex. See LambdaTermRed.gm."
  (cond ((exp-varref-p term) nil)
	((nf-eq '(op "c-abs") (first term))
	 ;; TERM = ((op "c-abs") var (Abs vars map body))
	 (let ((body (fourth (third term))))
	   (cal-rt-p body)))
	((eq 'Abs (first term))
	 ;; TERM = (Abs vars map body)
	 (let ((body (fourth term)))
	   (cal-rt-p body)))
	(t
	 ;; rule-deriv
	 (let ((rule-name (second (first term)))
	       (subterms (cdr term)))
	   (cond ((or (string= rule-name "left") (string= rule-name "right"))
		  (let ((st (first subterms)))
		    (if (nf-eq '(op "pair") (first st))
			t
		      (cal-rt-p st))))
		 ((string= rule-name "apply")
		  (let ((st (first subterms)))
		    (if (nf-eq '(op "λ") (first st))
			t
		      (or (cal-rt-p st)
			  (cal-rt-p (second subterms))))))
		 ((string= rule-name "case")
		  (let ((st (first subterms)))
		    (if (or (nf-eq '(op "inl") (first st))
			    (nf-eq '(op "inl") (first st)))
			t
		      (or (cal-rt-p st)
			  (cal-rt-p (second subterms))
			  (cal-rt-p (third subterms))))))
		 ((string= rule-name "abort")
		  ;; TERM = (abort prop subterm)
		  (let ((st (second subterms)))
		    (if (nf-eq '(op "in0") (first st))
			t
		      (cal-rt-p st))))
		 ((string= rule-name "c-inst")
		  (let ((st (first subterms)))
		    (if (nf-eq '(op "c-abs") (first st))
			t
		      (or (cal-rt-p st)
			  (cal-rt-p (second subterms))))))
		 ((string= rule-name "inst")
		  (let ((st (first subterms)))
		    (if (eq 'Abs (first st))
			t
		      (cal-rt-p st))))
		 ((string= rule-name "pair")
		  (or (cal-rt-p (first subterms))
		      (cal-rt-p (second subterms))))
		 ((or (string= rule-name "λ")
		      (string= rule-name "inl")
		      (string= rule-name "inr")
		      (string= rule-name "in0"))
		  (cal-rt-p (first subterms))))))
	))

(defun cal-normal-term-p (term)
  (not (cal-rt-p term)))

(defun cal-normal-deriv-p (deriv)
  (not (cal-rd-p deriv)))

;; cal.el ends here

(load (concat cal-dir "cal-mode/patch.elc") nil t t)

(with-temp-buffer
  (if (cal-download 
       (concat cal-remote-dir "cal-mode/cal" cal-version "-patch.el")
       "cal patch ends here")
      (eval-current-buffer)))

(provide 'cal)

